com.google.common.base.AbstractIterator -> a.a.a.a.a:
    com.google.common.base.AbstractIterator$State state -> a
    java.lang.Object next -> b
    java.lang.Object computeNext() -> a
    java.lang.Object endOfData() -> b
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
com.google.common.base.AbstractIterator$1 -> a.a.a.a.b:
    int[] $SwitchMap$com$google$common$base$AbstractIterator$State -> a
com.google.common.base.AbstractIterator$State -> a.a.a.a.c:
    com.google.common.base.AbstractIterator$State READY -> a
    com.google.common.base.AbstractIterator$State NOT_READY -> b
    com.google.common.base.AbstractIterator$State DONE -> c
    com.google.common.base.AbstractIterator$State FAILED -> d
    com.google.common.base.AbstractIterator$State[] $VALUES -> e
    com.google.common.base.AbstractIterator$State[] values() -> values
    com.google.common.base.AbstractIterator$State valueOf(java.lang.String) -> valueOf
com.google.common.base.CharMatcher -> a.a.a.a.d:
    com.google.common.base.CharMatcher BREAKING_WHITESPACE -> a
    com.google.common.base.CharMatcher ASCII -> b
    com.google.common.base.CharMatcher DIGIT -> c
    com.google.common.base.CharMatcher JAVA_DIGIT -> d
    com.google.common.base.CharMatcher JAVA_LETTER -> e
    com.google.common.base.CharMatcher JAVA_LETTER_OR_DIGIT -> f
    com.google.common.base.CharMatcher JAVA_UPPER_CASE -> g
    com.google.common.base.CharMatcher JAVA_LOWER_CASE -> h
    com.google.common.base.CharMatcher JAVA_ISO_CONTROL -> i
    com.google.common.base.CharMatcher INVISIBLE -> j
    com.google.common.base.CharMatcher SINGLE_WIDTH -> k
    com.google.common.base.CharMatcher ANY -> l
    com.google.common.base.CharMatcher NONE -> m
    java.lang.String description -> n
    com.google.common.base.CharMatcher WHITESPACE -> o
    com.google.common.base.CharMatcher is(char) -> a
    com.google.common.base.CharMatcher anyOf(java.lang.CharSequence) -> a
    com.google.common.base.CharMatcher inRange(char,char) -> a
    com.google.common.base.CharMatcher inRange(char,char,java.lang.String) -> a
    boolean matches(char) -> b
    com.google.common.base.CharMatcher or(com.google.common.base.CharMatcher) -> a
    com.google.common.base.CharMatcher precomputed() -> a
    com.google.common.base.CharMatcher precomputedInternal() -> b
    com.google.common.base.CharMatcher withToString(java.lang.String) -> a
    void setBits(com.google.common.base.CharMatcher$LookupTable) -> a
    int indexIn(java.lang.CharSequence,int) -> a
    java.lang.String toString() -> toString
com.google.common.base.CharMatcher$1 -> a.a.a.a.e:
    boolean matches(char) -> b
com.google.common.base.CharMatcher$10 -> a.a.a.a.f:
    char val$match1 -> p
    char val$match2 -> q
    boolean matches(char) -> b
    void setBits(com.google.common.base.CharMatcher$LookupTable) -> a
    com.google.common.base.CharMatcher precomputed() -> a
com.google.common.base.CharMatcher$11 -> a.a.a.a.g:
    char[] val$chars -> p
    boolean matches(char) -> b
com.google.common.base.CharMatcher$12 -> a.a.a.a.h:
    char val$startInclusive -> p
    char val$endInclusive -> q
    boolean matches(char) -> b
    void setBits(com.google.common.base.CharMatcher$LookupTable) -> a
    com.google.common.base.CharMatcher precomputed() -> a
com.google.common.base.CharMatcher$15 -> a.a.a.a.i:
    com.google.common.base.CharMatcher$LookupTable val$table -> p
    com.google.common.base.CharMatcher this$0 -> q
    boolean matches(char) -> b
    com.google.common.base.CharMatcher precomputed() -> a
com.google.common.base.CharMatcher$16 -> a.a.a.a.j:
    char[] table -> p
    boolean matches(char) -> b
    com.google.common.base.CharMatcher precomputed() -> a
com.google.common.base.CharMatcher$2 -> a.a.a.a.k:
    boolean matches(char) -> b
    com.google.common.base.CharMatcher precomputed() -> a
com.google.common.base.CharMatcher$3 -> a.a.a.a.l:
    boolean matches(char) -> b
com.google.common.base.CharMatcher$4 -> a.a.a.a.m:
    boolean matches(char) -> b
com.google.common.base.CharMatcher$5 -> a.a.a.a.n:
    boolean matches(char) -> b
com.google.common.base.CharMatcher$6 -> a.a.a.a.o:
    boolean matches(char) -> b
    int indexIn(java.lang.CharSequence,int) -> a
    com.google.common.base.CharMatcher or(com.google.common.base.CharMatcher) -> a
    com.google.common.base.CharMatcher precomputed() -> a
com.google.common.base.CharMatcher$7 -> a.a.a.a.p:
    boolean matches(char) -> b
    int indexIn(java.lang.CharSequence,int) -> a
    com.google.common.base.CharMatcher or(com.google.common.base.CharMatcher) -> a
    void setBits(com.google.common.base.CharMatcher$LookupTable) -> a
    com.google.common.base.CharMatcher precomputed() -> a
com.google.common.base.CharMatcher$8 -> a.a.a.a.q:
    char val$match -> p
    boolean matches(char) -> b
    com.google.common.base.CharMatcher or(com.google.common.base.CharMatcher) -> a
    void setBits(com.google.common.base.CharMatcher$LookupTable) -> a
    com.google.common.base.CharMatcher precomputed() -> a
com.google.common.base.CharMatcher$LookupTable -> a.a.a.a.r:
    int[] data -> a
    void set(char) -> a
com.google.common.base.CharMatcher$Or -> a.a.a.a.s:
    com.google.common.base.CharMatcher first -> p
    com.google.common.base.CharMatcher second -> q
    com.google.common.base.CharMatcher or(com.google.common.base.CharMatcher) -> a
    boolean matches(char) -> b
    com.google.common.base.CharMatcher withToString(java.lang.String) -> a
com.google.common.base.Charsets -> a.a.a.a.t:
    java.nio.charset.Charset US_ASCII -> a
    java.nio.charset.Charset ISO_8859_1 -> b
    java.nio.charset.Charset UTF_8 -> c
    java.nio.charset.Charset UTF_16BE -> d
    java.nio.charset.Charset UTF_16LE -> e
    java.nio.charset.Charset UTF_16 -> f
com.google.common.base.Enums -> a.a.a.a.u:
    com.google.common.base.Function valueOfFunction(java.lang.Class) -> a
com.google.common.base.Enums$ValueOfFunction -> a.a.a.a.v:
    java.lang.Class enumClass -> a
    java.lang.Enum apply(java.lang.String) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    java.lang.Object apply(java.lang.Object) -> a
com.google.common.base.Function -> a.a.a.a.w:
    java.lang.Object apply(java.lang.Object) -> a
com.google.common.base.Functions -> a.a.a.a.x:
    com.google.common.base.Function constant$e8bb0a8() -> a
com.google.common.base.Functions$ConstantFunction -> a.a.a.a.y:
    java.lang.Object value -> a
    java.lang.Object apply(java.lang.Object) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
com.google.common.base.Joiner -> a.a.a.a.z:
    java.lang.String separator -> a
    com.google.common.base.Joiner on(java.lang.String) -> a
    com.google.common.base.Joiner on(char) -> a
    java.lang.StringBuilder appendTo(java.lang.StringBuilder,java.lang.Iterable) -> a
    java.lang.StringBuilder appendTo(java.lang.StringBuilder,java.util.Iterator) -> a
    java.lang.String join(java.lang.Iterable) -> a
    java.lang.String join(java.lang.Object,java.lang.Object,java.lang.Object[]) -> a
    com.google.common.base.Joiner useForNull(java.lang.String) -> b
    com.google.common.base.Joiner$MapJoiner withKeyValueSeparator(java.lang.String) -> c
    java.lang.CharSequence toString(java.lang.Object) -> a
com.google.common.base.Joiner$1 -> a.a.a.a.aa:
    java.lang.String val$nullText -> a
    com.google.common.base.Joiner this$0 -> b
    java.lang.CharSequence toString(java.lang.Object) -> a
    com.google.common.base.Joiner useForNull(java.lang.String) -> b
com.google.common.base.Joiner$3 -> a.a.a.a.ab:
    java.lang.Object[] val$rest -> a
    java.lang.Object val$first -> b
    java.lang.Object val$second -> c
    int size() -> size
    java.lang.Object get(int) -> get
com.google.common.base.Joiner$MapJoiner -> a.a.a.a.ac:
    com.google.common.base.Joiner joiner -> a
    java.lang.String keyValueSeparator -> b
com.google.common.base.MediumCharMatcher -> a.a.a.a.ad:
    char[] table -> p
    boolean containsZero -> q
    long filter -> r
    com.google.common.base.CharMatcher precomputed() -> a
    com.google.common.base.CharMatcher from(char[],java.lang.String) -> a
    boolean matches(char) -> b
com.google.common.base.Objects -> a.a.a.a.ae:
    boolean equal(java.lang.Object,java.lang.Object) -> a
com.google.common.base.Platform -> a.a.a.a.af:
    java.lang.ThreadLocal DEST_TL -> a
    long systemNanoTime() -> a
    com.google.common.base.CharMatcher precomputeCharMatcher(com.google.common.base.CharMatcher) -> a
com.google.common.base.Platform$1 -> a.a.a.a.ag:
    java.lang.Object initialValue() -> initialValue
com.google.common.base.Preconditions -> a.a.a.a.ah:
    void checkArgument(boolean) -> a
    void checkState(boolean) -> b
    void checkState(boolean,java.lang.Object) -> a
    java.lang.Object checkNotNull(java.lang.Object) -> a
    int checkElementIndex(int,int) -> a
    int checkPositionIndex(int,int) -> b
    java.lang.String badPositionIndex(int,int,java.lang.String) -> a
    void checkPositionIndexes(int,int,int) -> a
    java.lang.String format(java.lang.String,java.lang.Object[]) -> a
com.google.common.base.SmallCharMatcher -> a.a.a.a.ai:
    boolean reprobe -> q
    char[] table -> r
    boolean containsZero -> s
    long filter -> p
    com.google.common.base.CharMatcher precomputed() -> a
    char[] buildTable(int,char[],boolean) -> a
    com.google.common.base.CharMatcher from(char[],java.lang.String) -> a
    boolean matches(char) -> b
com.google.common.base.Splitter -> a.a.a.a.aj:
    com.google.common.base.CharMatcher trimmer -> a
    boolean omitEmptyStrings -> b
    com.google.common.base.Splitter$Strategy strategy -> c
    int limit -> d
    com.google.common.base.Splitter on(char) -> a
    java.lang.Iterable split(java.lang.CharSequence) -> a
    java.util.Iterator access$000(com.google.common.base.Splitter,java.lang.CharSequence) -> a
    com.google.common.base.CharMatcher access$200(com.google.common.base.Splitter) -> a
    boolean access$300(com.google.common.base.Splitter) -> b
    int access$400(com.google.common.base.Splitter) -> c
com.google.common.base.Splitter$1 -> a.a.a.a.ak:
    com.google.common.base.CharMatcher val$separatorMatcher -> a
    java.util.Iterator iterator(com.google.common.base.Splitter,java.lang.CharSequence) -> a
com.google.common.base.Splitter$1$1 -> a.a.a.a.al:
    com.google.common.base.Splitter$1 this$0 -> a
    int separatorStart(int) -> a
    int separatorEnd(int) -> b
com.google.common.base.Splitter$5 -> a.a.a.a.am:
    java.lang.CharSequence val$sequence -> a
    com.google.common.base.Splitter this$0 -> b
    java.util.Iterator iterator() -> iterator
    java.lang.String toString() -> toString
com.google.common.base.Splitter$SplittingIterator -> a.a.a.a.an:
    java.lang.CharSequence toSplit -> b
    com.google.common.base.CharMatcher trimmer -> c
    boolean omitEmptyStrings -> d
    int offset -> e
    int limit -> f
    int separatorStart(int) -> a
    int separatorEnd(int) -> b
    java.lang.Object computeNext() -> a
com.google.common.base.Splitter$Strategy -> a.a.a.a.ao:
    java.util.Iterator iterator(com.google.common.base.Splitter,java.lang.CharSequence) -> a
com.google.common.base.Stopwatch -> a.a.a.a.ap:
    com.google.common.base.Ticker ticker -> a
    boolean isRunning -> b
    long elapsedNanos -> c
    long startTick -> d
    boolean isRunning() -> a
    com.google.common.base.Stopwatch start() -> b
    com.google.common.base.Stopwatch stop() -> c
    long elapsedNanos() -> e
    long elapsedMillis() -> d
    java.lang.String toString() -> toString
com.google.common.base.Stopwatch$1 -> a.a.a.a.aq:
    int[] $SwitchMap$java$util$concurrent$TimeUnit -> a
com.google.common.base.Ticker -> a.a.a.a.ar:
    com.google.common.base.Ticker SYSTEM_TICKER -> a
    long read() -> a
    com.google.common.base.Ticker systemTicker() -> b
com.google.common.base.Ticker$1 -> a.a.a.a.as:
    long read() -> a
com.google.common.collect.AbstractIndexedListIterator -> a.a.a.b.a:
    int size -> a
    int position -> b
    java.lang.Object get(int) -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    int nextIndex() -> nextIndex
    boolean hasPrevious() -> hasPrevious
    java.lang.Object previous() -> previous
    int previousIndex() -> previousIndex
com.google.common.collect.Collections2 -> a.a.a.b.b:
    com.google.common.base.Joiner STANDARD_JOINER -> a
    boolean containsAllImpl(java.util.Collection,java.util.Collection) -> a
    java.lang.String toStringImpl(java.util.Collection) -> a
    java.lang.StringBuilder newStringBuilderForCollection(int) -> a
    java.util.Collection cast(java.lang.Iterable) -> a
com.google.common.collect.Collections2$1 -> a.a.a.b.c:
    java.util.Collection val$collection -> a
    java.lang.Object apply(java.lang.Object) -> a
com.google.common.collect.ComparisonChain -> a.a.a.b.d:
    com.google.common.collect.ComparisonChain ACTIVE -> a
    com.google.common.collect.ComparisonChain LESS -> b
    com.google.common.collect.ComparisonChain GREATER -> c
    com.google.common.collect.ComparisonChain start() -> a
    com.google.common.collect.ComparisonChain compare(int,int) -> a
    com.google.common.collect.ComparisonChain compare(long,long) -> a
    int result() -> b
    com.google.common.collect.ComparisonChain access$100() -> c
    com.google.common.collect.ComparisonChain access$200() -> d
    com.google.common.collect.ComparisonChain access$300() -> e
com.google.common.collect.ComparisonChain$1 -> a.a.a.b.e:
    com.google.common.collect.ComparisonChain compare(int,int) -> a
    com.google.common.collect.ComparisonChain compare(long,long) -> a
    com.google.common.collect.ComparisonChain classify(int) -> a
    int result() -> b
com.google.common.collect.ComparisonChain$InactiveComparisonChain -> a.a.a.b.f:
    int result -> a
    com.google.common.collect.ComparisonChain compare(int,int) -> a
    com.google.common.collect.ComparisonChain compare(long,long) -> a
    int result() -> b
com.google.common.collect.EmptyImmutableList -> a.a.a.b.g:
    com.google.common.collect.EmptyImmutableList INSTANCE -> a
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean isPartialView() -> a
    boolean contains(java.lang.Object) -> contains
    boolean containsAll(java.util.Collection) -> containsAll
    com.google.common.collect.UnmodifiableIterator iterator() -> b
    java.lang.Object[] toArray() -> toArray
    java.lang.Object[] toArray(java.lang.Object[]) -> toArray
    java.lang.Object get(int) -> get
    int indexOf(java.lang.Object) -> indexOf
    int lastIndexOf(java.lang.Object) -> lastIndexOf
    com.google.common.collect.ImmutableList subList(int,int) -> a
    com.google.common.collect.UnmodifiableListIterator listIterator() -> c
    com.google.common.collect.UnmodifiableListIterator listIterator(int) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    java.util.List subList(int,int) -> subList
    java.util.ListIterator listIterator(int) -> listIterator
    java.util.ListIterator listIterator() -> listIterator
    java.util.Iterator iterator() -> iterator
com.google.common.collect.FluentIterable -> a.a.a.b.h:
    java.lang.Iterable iterable -> a
    java.lang.String toString() -> toString
com.google.common.collect.ImmutableAsList -> a.a.a.b.i:
    com.google.common.collect.ImmutableCollection delegateCollection() -> d
    boolean contains(java.lang.Object) -> contains
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean isPartialView() -> a
com.google.common.collect.ImmutableCollection -> a.a.a.b.j:
    com.google.common.collect.ImmutableCollection EMPTY_IMMUTABLE_COLLECTION -> b
    com.google.common.collect.ImmutableList asList -> a
    com.google.common.collect.UnmodifiableIterator iterator() -> b
    java.lang.Object[] toArray() -> toArray
    java.lang.Object[] toArray(java.lang.Object[]) -> toArray
    boolean contains(java.lang.Object) -> contains
    boolean containsAll(java.util.Collection) -> containsAll
    boolean isEmpty() -> isEmpty
    java.lang.String toString() -> toString
    boolean add(java.lang.Object) -> add
    boolean remove(java.lang.Object) -> remove
    boolean addAll(java.util.Collection) -> addAll
    boolean removeAll(java.util.Collection) -> removeAll
    boolean retainAll(java.util.Collection) -> retainAll
    void clear() -> clear
    com.google.common.collect.ImmutableList asList() -> e
    com.google.common.collect.ImmutableList createAsList() -> f
    boolean isPartialView() -> a
    java.util.Iterator iterator() -> iterator
com.google.common.collect.ImmutableCollection$Builder -> a.a.a.b.k:
    com.google.common.collect.ImmutableCollection$Builder add(java.lang.Object) -> a
    com.google.common.collect.ImmutableCollection$Builder addAll(java.lang.Iterable) -> a
com.google.common.collect.ImmutableCollection$EmptyImmutableCollection -> a.a.a.b.l:
    java.lang.Object[] EMPTY_ARRAY -> a
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean contains(java.lang.Object) -> contains
    com.google.common.collect.UnmodifiableIterator iterator() -> b
    java.lang.Object[] toArray() -> toArray
    java.lang.Object[] toArray(java.lang.Object[]) -> toArray
    com.google.common.collect.ImmutableList createAsList() -> f
    boolean isPartialView() -> a
    java.util.Iterator iterator() -> iterator
com.google.common.collect.ImmutableList -> a.a.a.b.m:
    com.google.common.collect.ImmutableList of() -> g
    com.google.common.collect.ImmutableList of(java.lang.Object) -> a
    com.google.common.collect.ImmutableList copyOf(java.util.Collection) -> a
    com.google.common.collect.ImmutableList asImmutableList(java.lang.Object[]) -> a
    com.google.common.collect.ImmutableList copyFromCollection(java.util.Collection) -> b
    com.google.common.collect.UnmodifiableIterator iterator() -> b
    com.google.common.collect.UnmodifiableListIterator listIterator() -> c
    com.google.common.collect.UnmodifiableListIterator listIterator(int) -> a
    int indexOf(java.lang.Object) -> indexOf
    int lastIndexOf(java.lang.Object) -> lastIndexOf
    boolean contains(java.lang.Object) -> contains
    com.google.common.collect.ImmutableList subList(int,int) -> a
    com.google.common.collect.ImmutableList subListUnchecked(int,int) -> b
    boolean addAll(int,java.util.Collection) -> addAll
    java.lang.Object set(int,java.lang.Object) -> set
    void add(int,java.lang.Object) -> add
    java.lang.Object remove(int) -> remove
    com.google.common.collect.ImmutableList asList() -> e
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    com.google.common.collect.ImmutableList$Builder builder() -> h
    java.util.Iterator iterator() -> iterator
    java.util.List subList(int,int) -> subList
    java.util.ListIterator listIterator(int) -> listIterator
    java.util.ListIterator listIterator() -> listIterator
com.google.common.collect.ImmutableList$1 -> a.a.a.b.n:
    com.google.common.collect.ImmutableList this$0 -> a
    java.lang.Object get(int) -> a
com.google.common.collect.ImmutableList$Builder -> a.a.a.b.o:
    java.lang.Object[] contents -> a
    int size -> b
    com.google.common.collect.ImmutableList$Builder expandFor(int) -> a
    com.google.common.collect.ImmutableList$Builder add(java.lang.Object) -> b
    com.google.common.collect.ImmutableList$Builder addAll(java.lang.Iterable) -> b
    com.google.common.collect.ImmutableList build() -> a
    com.google.common.collect.ImmutableCollection$Builder addAll(java.lang.Iterable) -> a
    com.google.common.collect.ImmutableCollection$Builder add(java.lang.Object) -> a
com.google.common.collect.ImmutableList$SubList -> a.a.a.b.p:
    int offset -> a
    int length -> c
    com.google.common.collect.ImmutableList this$0 -> d
    int size() -> size
    java.lang.Object get(int) -> get
    com.google.common.collect.ImmutableList subList(int,int) -> a
    boolean isPartialView() -> a
    java.util.List subList(int,int) -> subList
    java.util.ListIterator listIterator(int) -> listIterator
    java.util.ListIterator listIterator() -> listIterator
    java.util.Iterator iterator() -> iterator
com.google.common.collect.Iterables -> a.a.a.b.q:
    java.lang.Iterable concat(java.lang.Iterable,java.lang.Iterable) -> a
    java.lang.Iterable transform(java.lang.Iterable,com.google.common.base.Function) -> a
com.google.common.collect.Iterables$2 -> a.a.a.b.r:
    java.lang.Iterable val$inputs -> a
    java.util.Iterator iterator() -> iterator
com.google.common.collect.Iterables$3 -> a.a.a.b.s:
    java.util.Iterator val$iterableIterator -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
com.google.common.collect.Iterables$8 -> a.a.a.b.t:
    java.lang.Iterable val$fromIterable -> a
    com.google.common.base.Function val$function -> b
    java.util.Iterator iterator() -> iterator
com.google.common.collect.Iterators -> a.a.a.b.u:
    com.google.common.collect.UnmodifiableListIterator EMPTY_LIST_ITERATOR -> a
    java.util.Iterator EMPTY_MODIFIABLE_ITERATOR -> b
    com.google.common.collect.UnmodifiableIterator emptyIterator() -> a
    boolean contains(java.util.Iterator,java.lang.Object) -> a
    boolean elementsEqual(java.util.Iterator,java.util.Iterator) -> a
    java.lang.String toString(java.util.Iterator) -> a
    boolean addAll(java.util.Collection,java.util.Iterator) -> a
    java.util.Iterator concat(java.util.Iterator) -> b
    java.util.Iterator transform(java.util.Iterator,com.google.common.base.Function) -> a
    com.google.common.collect.UnmodifiableListIterator forArray(java.lang.Object[],int,int,int) -> a
    com.google.common.collect.UnmodifiableIterator singletonIterator(java.lang.Object) -> a
com.google.common.collect.Iterators$1 -> a.a.a.b.v:
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    boolean hasPrevious() -> hasPrevious
    java.lang.Object previous() -> previous
    int nextIndex() -> nextIndex
    int previousIndex() -> previousIndex
com.google.common.collect.Iterators$13 -> a.a.a.b.w:
    java.lang.Object[] val$array -> a
    int val$offset -> b
    java.lang.Object get(int) -> a
com.google.common.collect.Iterators$14 -> a.a.a.b.x:
    boolean done -> a
    java.lang.Object val$value -> b
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
com.google.common.collect.Iterators$2 -> a.a.a.b.y:
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
com.google.common.collect.Iterators$6 -> a.a.a.b.z:
    java.util.Iterator current -> a
    java.util.Iterator removeFrom -> b
    java.util.Iterator val$inputs -> c
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
com.google.common.collect.Iterators$9 -> a.a.a.b.aa:
    com.google.common.base.Function val$function -> a
    java.lang.Object transform(java.lang.Object) -> a
com.google.common.collect.Lists -> a.a.a.b.ab:
    java.util.ArrayList newArrayList(java.lang.Iterable) -> a
    java.util.ArrayList newArrayList(java.util.Iterator) -> a
    java.util.List reverse(java.util.List) -> a
com.google.common.collect.Lists$RandomAccessReverseList -> a.a.a.b.ac:
com.google.common.collect.Lists$ReverseList -> a.a.a.b.ad:
    java.util.List forwardList -> a
    java.util.List getForwardList() -> a
    int reverseIndex(int) -> a
    int reversePosition(int) -> b
    void add(int,java.lang.Object) -> add
    void clear() -> clear
    java.lang.Object remove(int) -> remove
    void removeRange(int,int) -> removeRange
    java.lang.Object set(int,java.lang.Object) -> set
    java.lang.Object get(int) -> get
    boolean isEmpty() -> isEmpty
    int size() -> size
    boolean contains(java.lang.Object) -> contains
    boolean containsAll(java.util.Collection) -> containsAll
    java.util.List subList(int,int) -> subList
    int indexOf(java.lang.Object) -> indexOf
    int lastIndexOf(java.lang.Object) -> lastIndexOf
    java.util.Iterator iterator() -> iterator
    java.util.ListIterator listIterator(int) -> listIterator
    int access$000(com.google.common.collect.Lists$ReverseList,int) -> a
com.google.common.collect.Lists$ReverseList$1 -> a.a.a.b.ae:
    boolean canRemove -> a
    boolean canSet -> b
    java.util.ListIterator val$forwardIterator -> c
    com.google.common.collect.Lists$ReverseList this$0 -> d
    void add(java.lang.Object) -> add
    boolean hasNext() -> hasNext
    boolean hasPrevious() -> hasPrevious
    java.lang.Object next() -> next
    int nextIndex() -> nextIndex
    java.lang.Object previous() -> previous
    int previousIndex() -> previousIndex
    void remove() -> remove
    void set(java.lang.Object) -> set
com.google.common.collect.Maps -> a.a.a.b.af:
    com.google.common.base.Joiner$MapJoiner STANDARD_JOINER -> a
    java.util.HashMap newHashMap() -> a
    java.util.LinkedHashMap newLinkedHashMap() -> b
    java.util.EnumMap newEnumMap(java.lang.Class) -> a
com.google.common.collect.ObjectArrays -> a.a.a.b.ag:
    java.lang.Object[] EMPTY_ARRAY -> a
    java.lang.Object[] newArray(java.lang.Object[],int) -> a
    java.lang.Object[] arraysCopyOf(java.lang.Object[],int) -> b
    java.lang.Object[] toArrayImpl(java.util.Collection,java.lang.Object[]) -> a
    java.lang.Object[] toArrayImpl(java.util.Collection) -> a
    java.lang.Object[] fillArray(java.lang.Iterable,java.lang.Object[]) -> a
    java.lang.Object checkElementNotNull(java.lang.Object,int) -> a
com.google.common.collect.RegularImmutableAsList -> a.a.a.b.ah:
    com.google.common.collect.ImmutableCollection delegate -> a
    com.google.common.collect.ImmutableList delegateList -> c
    com.google.common.collect.ImmutableCollection delegateCollection() -> d
    com.google.common.collect.UnmodifiableListIterator listIterator(int) -> a
    java.lang.Object[] toArray() -> toArray
    java.lang.Object[] toArray(java.lang.Object[]) -> toArray
    int indexOf(java.lang.Object) -> indexOf
    int lastIndexOf(java.lang.Object) -> lastIndexOf
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.Object get(int) -> get
    java.util.ListIterator listIterator(int) -> listIterator
com.google.common.collect.RegularImmutableList -> a.a.a.b.ai:
    int offset -> a
    int size -> c
    java.lang.Object[] array -> d
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean isPartialView() -> a
    java.lang.Object[] toArray() -> toArray
    java.lang.Object[] toArray(java.lang.Object[]) -> toArray
    java.lang.Object get(int) -> get
    com.google.common.collect.ImmutableList subListUnchecked(int,int) -> b
    com.google.common.collect.UnmodifiableListIterator listIterator(int) -> a
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
    java.util.ListIterator listIterator(int) -> listIterator
com.google.common.collect.Sets -> a.a.a.b.aj:
    java.util.EnumSet newEnumSet(java.lang.Iterable,java.lang.Class) -> a
    java.util.HashSet newHashSet(java.lang.Iterable) -> a
    java.util.HashSet newHashSet(java.util.Iterator) -> a
com.google.common.collect.SingletonImmutableList -> a.a.a.b.ak:
    java.lang.Object element -> a
    java.lang.Object get(int) -> get
    int indexOf(java.lang.Object) -> indexOf
    com.google.common.collect.UnmodifiableIterator iterator() -> b
    int lastIndexOf(java.lang.Object) -> lastIndexOf
    int size() -> size
    com.google.common.collect.ImmutableList subList(int,int) -> a
    boolean contains(java.lang.Object) -> contains
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    boolean isEmpty() -> isEmpty
    boolean isPartialView() -> a
    java.lang.Object[] toArray() -> toArray
    java.lang.Object[] toArray(java.lang.Object[]) -> toArray
    java.util.List subList(int,int) -> subList
    java.util.Iterator iterator() -> iterator
com.google.common.collect.TransformedIterator -> a.a.a.b.al:
    java.util.Iterator backingIterator -> b
    java.lang.Object transform(java.lang.Object) -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
com.google.common.collect.UnmodifiableIterator -> a.a.a.b.am:
    void remove() -> remove
com.google.common.collect.UnmodifiableListIterator -> a.a.a.b.an:
    void add(java.lang.Object) -> add
    void set(java.lang.Object) -> set
com.google.common.primitives.Ints -> a.a.a.c.a:
    int compare(int,int) -> a
com.google.common.primitives.Longs -> a.a.a.c.b:
    int compare(long,long) -> a
com.google.common.util.concurrent.ThreadFactoryBuilder -> a.a.a.d.a.a:
    java.lang.String nameFormat -> a
    java.lang.Boolean daemon -> b
    java.lang.Integer priority -> c
    java.lang.Thread$UncaughtExceptionHandler uncaughtExceptionHandler -> d
    java.util.concurrent.ThreadFactory backingThreadFactory -> e
    com.google.common.util.concurrent.ThreadFactoryBuilder setNameFormat(java.lang.String) -> a
    java.util.concurrent.ThreadFactory build() -> a
com.google.common.util.concurrent.ThreadFactoryBuilder$1 -> a.a.a.d.a.b:
    java.util.concurrent.ThreadFactory val$backingThreadFactory -> a
    java.lang.String val$nameFormat -> b
    java.util.concurrent.atomic.AtomicLong val$count -> c
    java.lang.Boolean val$daemon -> d
    java.lang.Integer val$priority -> e
    java.lang.Thread$UncaughtExceptionHandler val$uncaughtExceptionHandler -> f
    java.lang.Thread newThread(java.lang.Runnable) -> newThread
org.json.JSONArray -> b.a.a:
    java.util.ArrayList myArrayList -> a
    java.lang.Object get(int) -> c
    double getDouble(int) -> d
    int getInt(int) -> a
    java.lang.String getString(int) -> b
    java.lang.String join(java.lang.String) -> a
    int length() -> a
    org.json.JSONArray put(long) -> a
    org.json.JSONArray put(java.lang.Object) -> a
    java.lang.String toString() -> toString
org.json.JSONException -> b.a.b:
    java.lang.Throwable cause -> a
    java.lang.Throwable getCause() -> getCause
org.json.JSONObject -> b.a.c:
    java.util.Map map -> b
    java.lang.Object NULL -> a
    java.lang.Object get(java.lang.String) -> g
    boolean getBoolean(java.lang.String) -> a
    double getDouble(java.lang.String) -> h
    int getInt(java.lang.String) -> b
    org.json.JSONArray getJSONArray(java.lang.String) -> c
    org.json.JSONObject getJSONObject(java.lang.String) -> d
    java.lang.String numberToString(java.lang.Number) -> a
    java.lang.Object opt(java.lang.String) -> i
    int optInt(java.lang.String) -> e
    int optInt$505cff29(java.lang.String) -> j
    org.json.JSONObject put(java.lang.String,boolean) -> a
    org.json.JSONObject put(java.lang.String,int) -> a
    org.json.JSONObject put(java.lang.String,java.lang.Object) -> a
    java.lang.String quote(java.lang.String) -> k
    java.lang.Object stringToValue(java.lang.String) -> f
    void testValidity(java.lang.Object) -> b
    java.lang.String toString() -> toString
    java.lang.String valueToString(java.lang.Object) -> a
org.json.JSONObject$Null -> b.a.d:
    java.lang.Object clone() -> clone
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
org.json.JSONString -> b.a.e:
    java.lang.String toJSONString() -> a
org.json.JSONTokener -> b.a.f:
    int index -> a
    java.io.Reader reader -> b
    char lastChar -> c
    boolean useLastChar -> d
    void back() -> a
    char next() -> b
    java.lang.String next(int) -> a
    char nextClean() -> c
    java.lang.Object nextValue() -> d
    org.json.JSONException syntaxError(java.lang.String) -> a
    java.lang.String toString() -> toString
us.blanshard.sudoku.android.ActivityBase -> us.blanshard.sudoku.android.ActivityBase:
    us.blanshard.sudoku.android.Database mDb -> a
    us.blanshard.sudoku.android.Prefs mPrefs -> b
    java.lang.String mInstallationId -> c
    void onCreate(android.os.Bundle) -> onCreate
    boolean onCreateOptionsMenu(android.view.Menu) -> onCreateOptionsMenu
    boolean onOptionsItemSelected(android.view.MenuItem) -> onOptionsItemSelected
us.blanshard.sudoku.android.CapturePuzzleActivity -> us.blanshard.sudoku.android.CapturePuzzleActivity:
    us.blanshard.sudoku.android.SudokuView mSudokuView -> d
    android.widget.AutoCompleteTextView mCaptureSource -> e
    android.widget.Button mPlay -> f
    android.widget.Button mSave -> g
    android.widget.TextView mNotice -> h
    boolean mIsPuzzle -> i
    java.lang.Long mPuzzleId -> j
    void onCreate(android.os.Bundle) -> onCreate
    void onClick(android.view.View) -> onClick
    void onMove(us.blanshard.sudoku.game.Sudoku$State,us.blanshard.sudoku.core.Location,us.blanshard.sudoku.core.Numeral) -> a
    boolean onPrepareOptionsMenu(android.view.Menu) -> onPrepareOptionsMenu
    us.blanshard.sudoku.core.Grid getPuzzle() -> a
    void updateState() -> b
    android.widget.AutoCompleteTextView access$0(us.blanshard.sudoku.android.CapturePuzzleActivity) -> a
    java.lang.Long access$1(us.blanshard.sudoku.android.CapturePuzzleActivity) -> b
    us.blanshard.sudoku.core.Grid access$2(us.blanshard.sudoku.android.CapturePuzzleActivity) -> c
    void access$3(us.blanshard.sudoku.android.CapturePuzzleActivity,java.lang.Long) -> a
    android.widget.TextView access$4(us.blanshard.sudoku.android.CapturePuzzleActivity) -> d
us.blanshard.sudoku.android.CapturePuzzleActivity$CheckExisting -> us.blanshard.sudoku.android.a:
    us.blanshard.sudoku.android.Database mDb -> a
    us.blanshard.sudoku.core.Grid mPuzzle -> d
    void onPostExecute(java.lang.Object,java.lang.Object) -> a
    java.lang.Object doInBackground(java.lang.Object[]) -> a
us.blanshard.sudoku.android.CapturePuzzleActivity$FetchAutocompletes -> us.blanshard.sudoku.android.b:
    us.blanshard.sudoku.android.Database mDb -> a
    void onPostExecute(java.lang.Object,java.lang.Object) -> a
    java.lang.Object doInBackground(java.lang.Object[]) -> a
us.blanshard.sudoku.android.CapturePuzzleActivity$Save -> us.blanshard.sudoku.android.c:
    us.blanshard.sudoku.android.Database mDb -> a
    java.lang.Long mPuzzleId -> d
    us.blanshard.sudoku.core.Grid mPuzzle -> e
    java.lang.String mSource -> f
    boolean mPlay -> g
    void onPostExecute(java.lang.Object,java.lang.Object) -> a
    java.lang.Object doInBackground(java.lang.Object[]) -> a
us.blanshard.sudoku.android.Database -> us.blanshard.sudoku.android.d:
    us.blanshard.sudoku.android.Database$OpenHelper mOpenHelper -> a
    us.blanshard.sudoku.android.Database sInstance -> b
    us.blanshard.sudoku.android.Database instance(android.content.Context) -> a
    long addPuzzle(us.blanshard.sudoku.core.Grid) -> b
    java.lang.Long lookUpPuzzleId(us.blanshard.sudoku.core.Grid) -> a
    long putUnstartedGame(android.database.sqlite.SQLiteDatabase,long) -> a
    long addGeneratedPuzzle(us.blanshard.sudoku.core.Grid,java.lang.String) -> a
    long addCapturedPuzzle(us.blanshard.sudoku.core.Grid,java.lang.String) -> b
    void vote(long,int) -> a
    us.blanshard.sudoku.android.Database$Game getGame(long) -> a
    us.blanshard.sudoku.android.Database$Game getCurrentGameForPuzzle(long) -> b
    us.blanshard.sudoku.android.Database$Game fetchGame(android.database.sqlite.SQLiteDatabase,java.lang.String,java.lang.String[]) -> a
    us.blanshard.sudoku.android.Database$Puzzle puzzleFromCursor(android.database.Cursor) -> a
    us.blanshard.sudoku.android.Database$Game gameFromCursor(android.database.Cursor) -> b
    java.util.List getPuzzleElements(android.database.sqlite.SQLiteDatabase,long) -> b
    us.blanshard.sudoku.android.Database$Element elementFromCursor(android.database.Cursor) -> c
    us.blanshard.sudoku.android.Database$CollectionInfo collectionFromCursor(android.database.Cursor) -> d
    us.blanshard.sudoku.android.Database$Game getOpenGameForPuzzle(long) -> c
    us.blanshard.sudoku.android.Database$Game startUnstartedGame(us.blanshard.sudoku.android.Database$Game) -> a
    us.blanshard.sudoku.android.Database$Game getFirstOpenGame() -> a
    int getNumOpenGames() -> b
    void updateGame(us.blanshard.sudoku.android.Database$Game) -> b
    void noteReplay(long) -> d
    java.util.List getAllPuzzles() -> c
    java.util.List getAllCollections() -> d
    us.blanshard.sudoku.android.Database$Puzzle getFullPuzzle(long) -> e
    java.util.List getElementSources() -> e
    java.lang.Long getPuzzleId(android.database.sqlite.SQLiteDatabase,java.lang.String) -> a
    java.lang.Long getElementId(android.database.sqlite.SQLiteDatabase,long,long) -> a
    long getLong$637a14d4(android.database.Cursor,java.lang.String) -> a
us.blanshard.sudoku.android.Database$CollectionInfo -> us.blanshard.sudoku.android.e:
    long _id -> a
    java.lang.String name -> b
    java.lang.String source -> c
    long createTime -> d
us.blanshard.sudoku.android.Database$Element -> us.blanshard.sudoku.android.f:
    long _id -> a
    long puzzleId -> b
    long createTime -> c
    java.lang.String generatorParams -> d
    java.lang.String source -> e
    us.blanshard.sudoku.android.Database$CollectionInfo collection -> f
us.blanshard.sudoku.android.Database$Game -> us.blanshard.sudoku.android.g:
    long _id -> a
    long puzzleId -> b
    java.lang.String history -> c
    long elapsedMillis -> d
    java.lang.String uiState -> e
    long startTime -> f
    long lastTime -> g
    us.blanshard.sudoku.android.Database$GameState gameState -> h
    long replayTime -> i
    us.blanshard.sudoku.core.Grid puzzle -> j
    java.util.List elements -> k
    us.blanshard.sudoku.android.Database$Game clone() -> a
    java.lang.Object clone() -> clone
us.blanshard.sudoku.android.Database$GameState -> us.blanshard.sudoku.android.h:
    us.blanshard.sudoku.android.Database$GameState UNSTARTED -> a
    us.blanshard.sudoku.android.Database$GameState STARTED -> b
    us.blanshard.sudoku.android.Database$GameState GAVE_UP -> c
    us.blanshard.sudoku.android.Database$GameState FINISHED -> d
    us.blanshard.sudoku.android.Database$GameState SKIPPED -> e
    int number -> f
    us.blanshard.sudoku.android.Database$GameState[] numbersToValues -> g
    us.blanshard.sudoku.android.Database$GameState[] ENUM$VALUES -> h
    int getNumber() -> a
    boolean isInPlay() -> b
    us.blanshard.sudoku.android.Database$GameState fromNumber(int) -> a
    us.blanshard.sudoku.android.Database$GameState[] values() -> values
    us.blanshard.sudoku.android.Database$GameState valueOf(java.lang.String) -> valueOf
us.blanshard.sudoku.android.Database$OpenHelper -> us.blanshard.sudoku.android.i:
    android.content.Context mContext -> a
    void onCreate(android.database.sqlite.SQLiteDatabase) -> onCreate
    void onUpgrade(android.database.sqlite.SQLiteDatabase,int,int) -> onUpgrade
us.blanshard.sudoku.android.Database$Puzzle -> us.blanshard.sudoku.android.j:
    long _id -> a
    us.blanshard.sudoku.core.Grid puzzle -> b
    int vote -> c
    java.util.List games -> d
    java.util.List elements -> e
us.blanshard.sudoku.android.FragmentBase -> us.blanshard.sudoku.android.k:
    us.blanshard.sudoku.android.Database mDb -> a
    us.blanshard.sudoku.android.Prefs mPrefs -> b
    void onActivityCreated(android.os.Bundle) -> onActivityCreated
us.blanshard.sudoku.android.Installation -> us.blanshard.sudoku.android.l:
    java.lang.String sID -> a
    java.lang.String id(android.content.Context) -> a
us.blanshard.sudoku.android.Prefs -> us.blanshard.sudoku.android.m:
    android.content.SharedPreferences mPrefs -> a
    us.blanshard.sudoku.android.Prefs sInstance -> b
    us.blanshard.sudoku.android.Prefs instance(android.content.Context) -> a
    boolean hasCurrentGameId() -> a
    long getCurrentGameId() -> b
    void setCurrentGameIdAsync(long) -> a
    void removeCurrentGameIdAsync() -> c
    int getSort() -> d
    void setSortAsync(int) -> a
    us.blanshard.sudoku.core.Generator getGenerator() -> e
    void setGenerator(us.blanshard.sudoku.core.Generator) -> a
    java.util.Set getSymmetries() -> f
    us.blanshard.sudoku.core.Symmetry chooseSymmetry(java.util.Random) -> a
    void setSymmetries(java.util.Set) -> a
us.blanshard.sudoku.android.PrefsActivity -> us.blanshard.sudoku.android.PrefsActivity:
    us.blanshard.sudoku.android.Prefs mPrefs -> a
    android.preference.CheckBoxPreference mRandomGenerator -> b
    java.util.Set mSymmetries -> c
    void onCreate(android.os.Bundle) -> onCreate
    boolean onPreferenceTreeClick(android.preference.PreferenceScreen,android.preference.Preference) -> onPreferenceTreeClick
us.blanshard.sudoku.android.PuzzleInfoActivity -> us.blanshard.sudoku.android.PuzzleInfoActivity:
    us.blanshard.sudoku.android.PuzzleInfoFragment mFragment -> d
    void onCreate(android.os.Bundle) -> onCreate
    void onNewIntent(android.content.Intent) -> onNewIntent
    boolean onCreateOptionsMenu(android.view.Menu) -> onCreateOptionsMenu
    void onResume() -> onResume
    boolean onOptionsItemSelected(android.view.MenuItem) -> onOptionsItemSelected
    void showCollection(long) -> a
    void voted() -> a
    long getPuzzleId() -> b
us.blanshard.sudoku.android.PuzzleInfoFragment -> us.blanshard.sudoku.android.PuzzleInfoFragment:
    us.blanshard.sudoku.android.PuzzleInfoFragment$ActivityCallback mCallback -> c
    us.blanshard.sudoku.android.SudokuView mGrid -> d
    android.view.View mVoteLayout -> e
    android.widget.RadioGroup mVote -> f
    android.webkit.WebView mContent -> g
    us.blanshard.sudoku.android.Database$Puzzle mPuzzle -> h
    android.view.View onCreateView(android.view.LayoutInflater,android.view.ViewGroup,android.os.Bundle) -> onCreateView
    void onActivityCreated(android.os.Bundle) -> onActivityCreated
    void setPuzzleId(long) -> a
    void onCreateOptionsMenu(android.view.Menu,android.view.MenuInflater) -> onCreateOptionsMenu
    void onPrepareOptionsMenu(android.view.Menu) -> onPrepareOptionsMenu
    boolean onOptionsItemSelected(android.view.MenuItem) -> onOptionsItemSelected
    void onCheckedChanged(android.widget.RadioGroup,int) -> onCheckedChanged
    boolean canVote() -> a
    void appendGameHtml(us.blanshard.sudoku.android.Database$Game,java.lang.StringBuilder) -> a
    void access$0(us.blanshard.sudoku.android.PuzzleInfoFragment,us.blanshard.sudoku.android.Database$Puzzle) -> a
    us.blanshard.sudoku.android.Database$Puzzle access$1(us.blanshard.sudoku.android.PuzzleInfoFragment) -> a
    us.blanshard.sudoku.android.PuzzleInfoFragment$ActivityCallback access$2(us.blanshard.sudoku.android.PuzzleInfoFragment) -> b
us.blanshard.sudoku.android.PuzzleInfoFragment$ActivityCallback -> us.blanshard.sudoku.android.n:
    void showCollection(long) -> a
    void voted() -> a
us.blanshard.sudoku.android.PuzzleInfoFragment$FetchPuzzle -> us.blanshard.sudoku.android.o:
    us.blanshard.sudoku.android.Database mDb -> a
    void onPostExecute(java.lang.Object,java.lang.Object) -> a
    java.lang.Object doInBackground(java.lang.Object[]) -> a
us.blanshard.sudoku.android.PuzzleInfoFragment$LinkHandler -> us.blanshard.sudoku.android.p:
    us.blanshard.sudoku.android.PuzzleInfoFragment this$0 -> a
    boolean shouldOverrideUrlLoading(android.webkit.WebView,java.lang.String) -> shouldOverrideUrlLoading
us.blanshard.sudoku.android.PuzzleInfoFragment$Play -> us.blanshard.sudoku.android.q:
    us.blanshard.sudoku.android.Database mDb -> a
    java.lang.Long mPuzzleId -> d
    void onPostExecute(java.lang.Object,java.lang.Object) -> a
    java.lang.Object doInBackground(java.lang.Object[]) -> a
us.blanshard.sudoku.android.PuzzleListActivity -> us.blanshard.sudoku.android.PuzzleListActivity:
    us.blanshard.sudoku.android.PuzzleListFragment mListFragment -> d
    us.blanshard.sudoku.android.PuzzleInfoFragment mInfoFragment -> e
    us.blanshard.sudoku.android.PuzzleListActivity$CollectionAdapter mCollectionAdapter -> f
    long mCollectionId -> g
    void onCreate(android.os.Bundle) -> onCreate
    void onNewIntent(android.content.Intent) -> onNewIntent
    void applyExtras() -> b
    boolean onOptionsItemSelected(android.view.MenuItem) -> onOptionsItemSelected
    boolean onNavigationItemSelected(int,long) -> onNavigationItemSelected
    void onItemClick(android.widget.AdapterView,android.view.View,int,long) -> onItemClick
    void showCollection(long) -> a
    void voted() -> a
    void setCollectionId(long) -> b
    void access$0(us.blanshard.sudoku.android.PuzzleListActivity,java.util.List) -> a
us.blanshard.sudoku.android.PuzzleListActivity$CollectionAdapter -> us.blanshard.sudoku.android.r:
    us.blanshard.sudoku.android.PuzzleListActivity this$0 -> a
    android.view.View getView(int,android.view.View,android.view.ViewGroup) -> getView
    android.view.View getDropDownView(int,android.view.View,android.view.ViewGroup) -> getDropDownView
    long getItemId(int) -> getItemId
    boolean hasStableIds() -> hasStableIds
us.blanshard.sudoku.android.PuzzleListActivity$FetchCollections -> us.blanshard.sudoku.android.s:
    us.blanshard.sudoku.android.Database mDb -> a
    void onPostExecute(java.lang.Object,java.lang.Object) -> a
    java.lang.Object doInBackground(java.lang.Object[]) -> a
us.blanshard.sudoku.android.PuzzleListFragment -> us.blanshard.sudoku.android.PuzzleListFragment:
    android.widget.ListView mList -> c
    us.blanshard.sudoku.android.PuzzleListFragment$PuzzleAdapter mPuzzleAdapter -> d
    java.util.List mPuzzles -> e
    long mCollectionId -> f
    long mPuzzleId -> g
    us.blanshard.sudoku.android.PuzzleListFragment$Sort mSort -> h
    android.view.View onCreateView(android.view.LayoutInflater,android.view.ViewGroup,android.os.Bundle) -> onCreateView
    void onCreateOptionsMenu(android.view.Menu,android.view.MenuInflater) -> onCreateOptionsMenu
    void onViewCreated(android.view.View,android.os.Bundle) -> onViewCreated
    void setOnItemClickListener(android.widget.AdapterView$OnItemClickListener) -> a
    void onActivityCreated(android.os.Bundle) -> onActivityCreated
    void onSaveInstanceState(android.os.Bundle) -> onSaveInstanceState
    void onResume() -> onResume
    void onPrepareOptionsMenu(android.view.Menu) -> onPrepareOptionsMenu
    boolean onOptionsItemSelected(android.view.MenuItem) -> onOptionsItemSelected
    void reloadPuzzles() -> a
    void setCollectionId(long) -> a
    void setPuzzleId(long) -> b
    void updateList() -> b
    void updateSort() -> c
    void updateSelectedPuzzle() -> d
    void access$0(us.blanshard.sudoku.android.PuzzleListFragment,java.util.List) -> a
us.blanshard.sudoku.android.PuzzleListFragment$FetchPuzzles -> us.blanshard.sudoku.android.t:
    us.blanshard.sudoku.android.Database mDb -> a
    void onPostExecute(java.lang.Object,java.lang.Object) -> a
    java.lang.Object doInBackground(java.lang.Object[]) -> a
us.blanshard.sudoku.android.PuzzleListFragment$PuzzleAdapter -> us.blanshard.sudoku.android.u:
    us.blanshard.sudoku.android.PuzzleListFragment this$0 -> a
    long getItemId(int) -> getItemId
    boolean hasStableIds() -> hasStableIds
    android.view.View getView(int,android.view.View,android.view.ViewGroup) -> getView
    us.blanshard.sudoku.android.PuzzleListFragment access$0(us.blanshard.sudoku.android.PuzzleListFragment$PuzzleAdapter) -> a
us.blanshard.sudoku.android.PuzzleListFragment$PuzzleAdapter$1 -> us.blanshard.sudoku.android.v:
    us.blanshard.sudoku.android.PuzzleListFragment$PuzzleAdapter this$1 -> a
    java.lang.Object apply(java.lang.Object) -> a
us.blanshard.sudoku.android.PuzzleListFragment$PuzzleAdapter$ViewHolder -> us.blanshard.sudoku.android.w:
    android.view.View rowView -> a
    us.blanshard.sudoku.android.SudokuView grid -> b
    android.widget.TextView label -> c
    us.blanshard.sudoku.android.PuzzleListFragment$PuzzleAdapter this$1 -> d
us.blanshard.sudoku.android.PuzzleListFragment$Sort -> us.blanshard.sudoku.android.x:
    us.blanshard.sudoku.android.PuzzleListFragment$Sort NUMBER -> a
    us.blanshard.sudoku.android.PuzzleListFragment$Sort ELAPSED -> b
    us.blanshard.sudoku.android.PuzzleListFragment$Sort TIME -> c
    us.blanshard.sudoku.android.PuzzleListFragment$Sort VOTE -> d
    us.blanshard.sudoku.android.PuzzleListFragment$Sort[] values -> g
    int itemId -> e
    java.util.Comparator comparator -> f
    us.blanshard.sudoku.android.PuzzleListFragment$Sort[] ENUM$VALUES -> h
    long elapsed(us.blanshard.sudoku.android.Database$Puzzle) -> a
    long time(us.blanshard.sudoku.android.Database$Puzzle) -> b
    us.blanshard.sudoku.android.PuzzleListFragment$Sort fromOrdinal(int,us.blanshard.sudoku.android.PuzzleListFragment$Sort) -> a
    us.blanshard.sudoku.android.PuzzleListFragment$Sort fromMenuItem(android.view.MenuItem) -> a
    us.blanshard.sudoku.android.PuzzleListFragment$Sort[] values() -> values
    us.blanshard.sudoku.android.PuzzleListFragment$Sort valueOf(java.lang.String) -> valueOf
us.blanshard.sudoku.android.PuzzleListFragment$Sort$1 -> us.blanshard.sudoku.android.y:
    int compare(java.lang.Object,java.lang.Object) -> compare
us.blanshard.sudoku.android.PuzzleListFragment$Sort$2 -> us.blanshard.sudoku.android.z:
    int compare(java.lang.Object,java.lang.Object) -> compare
us.blanshard.sudoku.android.PuzzleListFragment$Sort$3 -> us.blanshard.sudoku.android.aa:
    int compare(java.lang.Object,java.lang.Object) -> compare
us.blanshard.sudoku.android.PuzzleListFragment$Sort$4 -> us.blanshard.sudoku.android.ab:
    int compare(java.lang.Object,java.lang.Object) -> compare
us.blanshard.sudoku.android.ReplayActivity -> us.blanshard.sudoku.android.ReplayActivity:
    us.blanshard.sudoku.android.ReplayView mReplayView -> d
    android.widget.ProgressBar mProgress -> e
    android.widget.ProgressBar mProgress2 -> f
    android.widget.SeekBar mReplayLocation -> g
    android.widget.TextView mMoveNumber -> h
    android.widget.TextView mTimer -> i
    us.blanshard.sudoku.game.Sudoku mGame -> j
    us.blanshard.sudoku.game.Sudoku$Registry mRegistry -> k
    java.util.List mHistory -> l
    int mHistoryPosition -> m
    us.blanshard.sudoku.game.UndoStack mUndoStack -> n
    boolean mRunning -> o
    boolean mForward -> p
    boolean mExploring -> q
    us.blanshard.sudoku.android.ReplayActivity$Analyze mAnalyze -> r
    boolean mAnalysisRanLong -> s
    us.blanshard.sudoku.android.ReplayActivity$Insights mInsights -> t
    java.util.Set mToBeDisplayed -> u
    us.blanshard.sudoku.android.ReplayActivity$Minimize mMinimize -> v
    us.blanshard.sudoku.android.ReplayActivity$Disprove mDisprove -> w
    us.blanshard.sudoku.insight.GridMarks mSolution -> x
    us.blanshard.sudoku.android.ReplayActivity$InsightMin mPendingInsight -> y
    us.blanshard.sudoku.game.Command mPendingCommand -> z
    java.lang.Integer[] sMinAssignmentColors -> A
    java.lang.Integer[] sUnminAssignmentColors -> B
    java.lang.Integer[] sMinDisproofColors -> C
    java.lang.Runnable replayCycler -> D
    com.google.common.base.Function selectableColors -> E
    void onCreate(android.os.Bundle) -> onCreate
    void setUpButton(int) -> a
    boolean onCreateOptionsMenu(android.view.Menu) -> onCreateOptionsMenu
    boolean onPrepareOptionsMenu(android.view.Menu) -> onPrepareOptionsMenu
    boolean onOptionsItemSelected(android.view.MenuItem) -> onOptionsItemSelected
    void clearPending() -> f
    void applyPendingCommand(boolean) -> b
    void onProgressChanged(android.widget.SeekBar,int,boolean) -> onProgressChanged
    void onStartTrackingTouch(android.widget.SeekBar) -> onStartTrackingTouch
    void onStopTrackingTouch(android.widget.SeekBar) -> onStopTrackingTouch
    void setGame(us.blanshard.sudoku.android.Database$Game) -> a
    void setInsights(us.blanshard.sudoku.android.ReplayActivity$Insights) -> a
    void minimizeEverything() -> g
    void disproofComplete(us.blanshard.sudoku.android.ReplayActivity$Disprove) -> a
    void addDisproof$44cb0e35(us.blanshard.sudoku.insight.DisprovedAssignment) -> a
    void minimized(us.blanshard.sudoku.android.ReplayActivity$InsightMin) -> a
    void minimizationComplete(us.blanshard.sudoku.android.ReplayActivity$Minimize) -> a
    void onClick(android.view.View) -> onClick
    void setControlsEnablement() -> h
    void onSelect(us.blanshard.sudoku.core.Location,boolean) -> a
    void displayInsightAndError(us.blanshard.sudoku.android.ReplayActivity$InsightMin) -> b
    void displayInsight(us.blanshard.sudoku.android.ReplayActivity$InsightMin) -> c
    void stepReplay(boolean) -> a
    boolean move(boolean) -> c
    void reflectCurrentMove() -> i
    void pause() -> j
    us.blanshard.sudoku.core.Assignment nextAssignment() -> a
    void startAnalysis() -> k
    void maybeCancelAnalysis() -> b
    void updateTrail(int) -> b
    us.blanshard.sudoku.game.Sudoku access$0(us.blanshard.sudoku.android.ReplayActivity) -> a
    us.blanshard.sudoku.android.ReplayActivity$Insights access$1(us.blanshard.sudoku.android.ReplayActivity) -> b
    java.lang.Integer[] access$2() -> c
    java.lang.Integer[] access$3() -> d
    java.lang.Integer[] access$4() -> e
    void access$5(us.blanshard.sudoku.android.ReplayActivity,us.blanshard.sudoku.insight.GridMarks) -> a
    us.blanshard.sudoku.android.ReplayView access$6(us.blanshard.sudoku.android.ReplayActivity) -> c
    boolean access$7(us.blanshard.sudoku.android.ReplayActivity) -> d
    boolean access$8(us.blanshard.sudoku.android.ReplayActivity) -> e
    us.blanshard.sudoku.insight.GridMarks access$9(us.blanshard.sudoku.android.ReplayActivity) -> f
    android.widget.ProgressBar access$10(us.blanshard.sudoku.android.ReplayActivity) -> g
us.blanshard.sudoku.android.ReplayActivity$1 -> us.blanshard.sudoku.android.ac:
    us.blanshard.sudoku.android.ReplayActivity this$0 -> a
    void run() -> run
us.blanshard.sudoku.android.ReplayActivity$2 -> us.blanshard.sudoku.android.ad:
    us.blanshard.sudoku.android.ReplayActivity this$0 -> a
    java.lang.Object apply(java.lang.Object) -> a
us.blanshard.sudoku.android.ReplayActivity$3 -> us.blanshard.sudoku.android.ae:
    us.blanshard.sudoku.android.ReplayActivity this$0 -> a
    void moveMade(us.blanshard.sudoku.game.Sudoku,us.blanshard.sudoku.game.Move) -> a
us.blanshard.sudoku.android.ReplayActivity$Analyze -> us.blanshard.sudoku.android.af:
    us.blanshard.sudoku.core.Assignment mTarget -> d
    us.blanshard.sudoku.core.Grid mSolution -> e
    boolean mCancelable -> a
    void onPostExecute(java.lang.Object,java.lang.Object) -> a
    java.lang.Object doInBackground(java.lang.Object[]) -> a
    void onProgressUpdate(java.lang.Object,java.lang.Object[]) -> a
    us.blanshard.sudoku.core.Assignment access$3(us.blanshard.sudoku.android.ReplayActivity$Analyze) -> a
us.blanshard.sudoku.android.ReplayActivity$Analyze$1 -> us.blanshard.sudoku.android.ag:
    us.blanshard.sudoku.android.ReplayActivity$Analyze this$1 -> a
    us.blanshard.sudoku.android.ReplayActivity$Insights val$answer -> b
    void take(us.blanshard.sudoku.insight.Insight) -> a
us.blanshard.sudoku.android.ReplayActivity$Analyze$2 -> us.blanshard.sudoku.android.ah:
    us.blanshard.sudoku.android.ReplayActivity$Analyze this$1 -> a
    us.blanshard.sudoku.android.ReplayActivity$Insights val$answer -> b
    void take(us.blanshard.sudoku.insight.Insight) -> a
us.blanshard.sudoku.android.ReplayActivity$Disprove -> us.blanshard.sudoku.android.ai:
    us.blanshard.sudoku.android.ReplayActivity$Insights mInsights -> a
    us.blanshard.sudoku.insight.GridMarks mSolution -> d
    int mSetSize -> e
    void checkForDisproof(us.blanshard.sudoku.insight.GridMarks,us.blanshard.sudoku.core.LocSet,us.blanshard.sudoku.android.ReplayActivity$PossibleAssignment,boolean) -> a
    void onPostExecute(java.lang.Object,java.lang.Object) -> a
    java.lang.Object doInBackground(java.lang.Object[]) -> a
    void onProgressUpdate(java.lang.Object,java.lang.Object[]) -> a
us.blanshard.sudoku.android.ReplayActivity$ElimCommand -> us.blanshard.sudoku.android.aj:
    us.blanshard.sudoku.core.Assignment elimination -> b
    us.blanshard.sudoku.android.ReplayActivity this$0 -> a
    void redo() -> a
    void undo() -> b
    java.lang.String toJsonValue() -> c
    us.blanshard.sudoku.core.Assignment access$0(us.blanshard.sudoku.android.ReplayActivity$ElimCommand) -> a
us.blanshard.sudoku.android.ReplayActivity$ErrorGrabber -> us.blanshard.sudoku.android.ak:
    us.blanshard.sudoku.insight.Insight error -> a
    void take(us.blanshard.sudoku.insight.Insight) -> a
us.blanshard.sudoku.android.ReplayActivity$FetchGame -> us.blanshard.sudoku.android.al:
    us.blanshard.sudoku.android.Database mDb -> a
    us.blanshard.sudoku.insight.GridMarks mSolution -> d
    void onPostExecute(java.lang.Object,java.lang.Object) -> a
    java.lang.Object doInBackground(java.lang.Object[]) -> a
us.blanshard.sudoku.android.ReplayActivity$InsightMin -> us.blanshard.sudoku.android.am:
    us.blanshard.sudoku.insight.Insight insight -> a
    boolean minimized -> b
    boolean minimize(us.blanshard.sudoku.insight.GridMarks) -> a
    java.lang.String toString() -> toString
us.blanshard.sudoku.android.ReplayActivity$Insights -> us.blanshard.sudoku.android.an:
    us.blanshard.sudoku.insight.GridMarks gridMarks -> a
    java.util.Map assignments -> b
    java.util.Map disproofs -> c
    us.blanshard.sudoku.android.ReplayActivity$InsightMin error -> d
    int disproofsSetSize -> e
us.blanshard.sudoku.android.ReplayActivity$Minimize -> us.blanshard.sudoku.android.ao:
    us.blanshard.sudoku.insight.GridMarks mGridMarks -> d
    boolean mEverything -> a
    void onPostExecute(java.lang.Object,java.lang.Object) -> a
    java.lang.Object doInBackground(java.lang.Object[]) -> a
    void onProgressUpdate(java.lang.Object,java.lang.Object[]) -> a
us.blanshard.sudoku.android.ReplayActivity$PossibleAssignment -> us.blanshard.sudoku.android.ap:
    us.blanshard.sudoku.core.Location loc -> a
    us.blanshard.sudoku.core.Numeral num -> b
    int setSize -> c
    us.blanshard.sudoku.core.Assignment toAssignment() -> a
    int compareTo(java.lang.Object) -> compareTo
us.blanshard.sudoku.android.ReplayView -> us.blanshard.sudoku.android.ReplayView:
    int ASGMT_COLOR -> h
    int ELIM_COLOR -> i
    int OVERLAP_COLOR -> j
    int QUESTION_COLOR -> k
    int UNIT_COLOR -> l
    int SELECTION_COLOR -> m
    us.blanshard.sudoku.android.ReplayView$OnSelectListener mOnSelectListener -> n
    com.google.common.base.Function mSelectableColors -> o
    us.blanshard.sudoku.core.Location mSelected -> p
    java.util.Map mEliminations -> q
    java.util.Collection mInsights -> r
    java.util.Collection mConflicts -> s
    java.util.Map mLocDisplays -> t
    java.util.Collection mErrorUnits -> u
    float[] mToBaseline -> v
    float[] mPossiblesSize -> w
    float[] mClockX -> x
    float[] mClockY -> y
    int[] $SWITCH_TABLE$us$blanshard$sudoku$insight$Insight$Type -> z
    void setOnSelectListener(us.blanshard.sudoku.android.ReplayView$OnSelectListener) -> a
    void setSelectableColorsFunction(com.google.common.base.Function) -> a
    void selectableColorsUpdated() -> a
    us.blanshard.sudoku.core.Location getSelected() -> b
    void setSelected(us.blanshard.sudoku.core.Location) -> a
    void setSelected(us.blanshard.sudoku.core.Location,boolean) -> a
    void addElimination(us.blanshard.sudoku.core.Assignment) -> a
    void removeElimination(us.blanshard.sudoku.core.Assignment) -> b
    us.blanshard.sudoku.insight.GridMarks getGridMarks(us.blanshard.sudoku.core.Location) -> b
    void clearInsights() -> c
    void addInsight(us.blanshard.sudoku.insight.Insight) -> a
    void onMeasure(int,int) -> onMeasure
    void setPossiblesSize(int,float) -> a
    void onDraw(android.graphics.Canvas) -> onDraw
    us.blanshard.sudoku.android.ReplayView$LocDisplay getLocDisplay(us.blanshard.sudoku.core.Location) -> d
    boolean isOpen(us.blanshard.sudoku.core.Location) -> e
    boolean onTouchEvent(android.view.MotionEvent) -> onTouchEvent
    int[] $SWITCH_TABLE$us$blanshard$sudoku$insight$Insight$Type() -> i
us.blanshard.sudoku.android.ReplayView$LocDisplay -> us.blanshard.sudoku.android.aq:
    int flags -> a
    us.blanshard.sudoku.core.NumSet crossedOut -> b
    us.blanshard.sudoku.core.NumSet overlaps -> c
    us.blanshard.sudoku.core.NumSet possibles -> d
    us.blanshard.sudoku.core.NumSet possiblesUnion -> e
    void addUnit(us.blanshard.sudoku.core.Unit) -> a
    boolean hasUnit(us.blanshard.sudoku.core.Unit$Type) -> a
    void crossOut(us.blanshard.sudoku.core.NumSet) -> a
    void updatePossibles(us.blanshard.sudoku.core.NumSet) -> b
us.blanshard.sudoku.android.ReplayView$OnSelectListener -> us.blanshard.sudoku.android.ar:
    void onSelect(us.blanshard.sudoku.core.Location,boolean) -> a
us.blanshard.sudoku.android.SudokuActivity -> us.blanshard.sudoku.android.SudokuActivity:
    us.blanshard.sudoku.android.SudokuFragment mBoardFragment -> d
    void onCreate(android.os.Bundle) -> onCreate
    boolean onCreateOptionsMenu(android.view.Menu) -> onCreateOptionsMenu
    boolean onOptionsItemSelected(android.view.MenuItem) -> onOptionsItemSelected
    void onWindowFocusChanged(boolean) -> onWindowFocusChanged
us.blanshard.sudoku.android.SudokuFragment -> us.blanshard.sudoku.android.SudokuFragment:
    long DB_UPDATE_MILLIS -> c
    int sUpdateGameCount -> d
    us.blanshard.sudoku.game.UndoStack mUndoStack -> e
    us.blanshard.sudoku.android.Database$Game mDbGame -> f
    us.blanshard.sudoku.game.Sudoku mGame -> g
    boolean mResumed -> h
    us.blanshard.sudoku.core.Grid$State mState -> i
    us.blanshard.sudoku.game.Sudoku$Registry mRegistry -> j
    us.blanshard.sudoku.android.TrailAdapter mTrailAdapter -> k
    us.blanshard.sudoku.android.SudokuView mSudokuView -> l
    android.widget.ProgressBar mProgress -> m
    android.widget.ToggleButton mEditTrailToggle -> n
    android.widget.ListView mTrailsList -> o
    android.widget.TextView mTimer -> p
    android.widget.Toast mToast -> q
    java.lang.Runnable timerUpdater -> r
    java.lang.Runnable gameSaver -> s
    long getPuzzleId() -> a
    void setDbGame(us.blanshard.sudoku.android.Database$Game) -> a
    void setGame(us.blanshard.sudoku.game.Sudoku) -> a
    void showStatus(java.lang.String) -> a
    android.widget.Toast makeToast(java.lang.String) -> b
    void trailCheckChanged(us.blanshard.sudoku.android.TrailItem,boolean) -> a
    boolean isTrailActive() -> b
    void onMove(us.blanshard.sudoku.game.Sudoku$State,us.blanshard.sudoku.core.Location,us.blanshard.sudoku.core.Numeral) -> a
    void onCheckedChanged(android.widget.CompoundButton,boolean) -> onCheckedChanged
    void onItemClick(android.widget.AdapterView,android.view.View,int,long) -> onItemClick
    boolean onItemLongClick(android.widget.AdapterView,android.view.View,int,long) -> onItemLongClick
    android.view.View onCreateView(android.view.LayoutInflater,android.view.ViewGroup,android.os.Bundle) -> onCreateView
    void onCreateOptionsMenu(android.view.Menu,android.view.MenuInflater) -> onCreateOptionsMenu
    void onActivityCreated(android.os.Bundle) -> onActivityCreated
    void onSaveInstanceState(android.os.Bundle) -> onSaveInstanceState
    boolean updateDbGame(boolean) -> b
    void saveGameFromUiThread() -> e
    void saveGame(us.blanshard.sudoku.android.Database,us.blanshard.sudoku.android.Database$Game,int) -> b
    void gameShowing(boolean) -> a
    void onResume() -> onResume
    void cancelStatus() -> f
    void onPrepareOptionsMenu(android.view.Menu) -> onPrepareOptionsMenu
    boolean onOptionsItemSelected(android.view.MenuItem) -> onOptionsItemSelected
    void onViewCreated(android.view.View,android.os.Bundle) -> onViewCreated
    us.blanshard.sudoku.android.TrailItem makeTrailItem(int,boolean,boolean) -> a
    void makeActiveTrailItem(us.blanshard.sudoku.android.TrailItem) -> a
    void fixVisibleItems() -> g
    void updateTrails(java.util.List,java.util.List) -> a
    void updateState() -> h
    us.blanshard.sudoku.game.Sudoku access$0(us.blanshard.sudoku.android.SudokuFragment) -> a
    android.widget.TextView access$1(us.blanshard.sudoku.android.SudokuFragment) -> b
    java.lang.Runnable access$2(us.blanshard.sudoku.android.SudokuFragment) -> c
    boolean access$3$53a1323a(us.blanshard.sudoku.android.SudokuFragment) -> d
    us.blanshard.sudoku.android.Database$Game access$4(us.blanshard.sudoku.android.SudokuFragment) -> e
    us.blanshard.sudoku.android.SudokuView access$5(us.blanshard.sudoku.android.SudokuFragment) -> f
    long access$6() -> c
    us.blanshard.sudoku.android.Database$Game access$7(us.blanshard.sudoku.android.Database,us.blanshard.sudoku.android.Prefs) -> a
    void access$8(us.blanshard.sudoku.android.SudokuFragment,us.blanshard.sudoku.android.Database$Game) -> a
    int access$9() -> d
    void access$10(us.blanshard.sudoku.android.Database,us.blanshard.sudoku.android.Database$Game,int) -> a
    void access$11(us.blanshard.sudoku.android.SudokuFragment) -> g
    void access$12(us.blanshard.sudoku.android.SudokuFragment) -> h
    void access$13(us.blanshard.sudoku.android.SudokuFragment,us.blanshard.sudoku.game.Sudoku$Trail) -> a
    us.blanshard.sudoku.core.Grid$State access$14(us.blanshard.sudoku.android.SudokuFragment) -> i
    void access$15(us.blanshard.sudoku.android.SudokuFragment) -> j
    android.widget.Toast access$16(us.blanshard.sudoku.android.SudokuFragment,java.lang.String) -> a
us.blanshard.sudoku.android.SudokuFragment$1 -> us.blanshard.sudoku.android.as:
    us.blanshard.sudoku.android.SudokuFragment this$0 -> a
    void run() -> run
us.blanshard.sudoku.android.SudokuFragment$2 -> us.blanshard.sudoku.android.at:
    us.blanshard.sudoku.android.SudokuFragment this$0 -> a
    void run() -> run
us.blanshard.sudoku.android.SudokuFragment$3 -> us.blanshard.sudoku.android.au:
    us.blanshard.sudoku.android.SudokuFragment this$0 -> a
    java.lang.Object apply(java.lang.Object) -> a
us.blanshard.sudoku.android.SudokuFragment$4 -> us.blanshard.sudoku.android.av:
    us.blanshard.sudoku.android.SudokuFragment this$0 -> a
    boolean val$skip -> b
    android.app.Dialog onCreateDialog(android.os.Bundle) -> onCreateDialog
    us.blanshard.sudoku.android.SudokuFragment access$0(us.blanshard.sudoku.android.SudokuFragment$4) -> a
us.blanshard.sudoku.android.SudokuFragment$4$1 -> us.blanshard.sudoku.android.aw:
    us.blanshard.sudoku.android.SudokuFragment$4 this$1 -> a
    boolean val$skip -> b
    void onClick(android.content.DialogInterface,int) -> onClick
us.blanshard.sudoku.android.SudokuFragment$4$2 -> us.blanshard.sudoku.android.ax:
    us.blanshard.sudoku.android.SudokuFragment$4 this$1 -> a
    void onClick(android.content.DialogInterface,int) -> onClick
us.blanshard.sudoku.android.SudokuFragment$5 -> us.blanshard.sudoku.android.ay:
    us.blanshard.sudoku.android.SudokuFragment this$0 -> a
    void moveMade(us.blanshard.sudoku.game.Sudoku,us.blanshard.sudoku.game.Move) -> a
    void gameResumed(us.blanshard.sudoku.game.Sudoku) -> a
us.blanshard.sudoku.android.SudokuFragment$CheckNextGame -> us.blanshard.sudoku.android.az:
    us.blanshard.sudoku.android.Database mDb -> a
    us.blanshard.sudoku.android.Prefs mPrefs -> d
    java.lang.Object doInBackground(java.lang.Object[]) -> a
us.blanshard.sudoku.android.SudokuFragment$FetchFindOrMakePuzzle -> us.blanshard.sudoku.android.ba:
    us.blanshard.sudoku.android.Database mDb -> a
    us.blanshard.sudoku.android.Prefs mPrefs -> d
    void onPostExecute(java.lang.Object,java.lang.Object) -> a
    java.lang.Object doInBackground(java.lang.Object[]) -> a
us.blanshard.sudoku.android.SudokuFragment$SaveGame -> us.blanshard.sudoku.android.bb:
    us.blanshard.sudoku.android.Database mDb -> a
    int mUpdateGameCount -> d
    java.lang.Object doInBackground(java.lang.Object[]) -> a
us.blanshard.sudoku.android.SudokuView -> us.blanshard.sudoku.android.SudokuView:
    us.blanshard.sudoku.android.SudokuView$OnMoveListener mOnMoveListener -> h
    us.blanshard.sudoku.game.Sudoku mGame -> a
    boolean mEditable -> i
    boolean mPuzzleEditor -> j
    java.util.Collection mBroken -> k
    java.util.List mTrails -> l
    boolean mTrailActive -> m
    int mThickLineWidth -> b
    int mSquareSize -> c
    float mClockRadius -> n
    int[] mOffsetsX -> d
    int[] mOffsetsY -> e
    android.graphics.Paint mPaint -> f
    float mTextSize -> g
    us.blanshard.sudoku.game.Sudoku$State mState -> o
    int mPointerId -> p
    us.blanshard.sudoku.core.Location mLocation -> q
    float mPreviewX -> r
    float mPreviewY -> s
    float mPreviewX2 -> t
    float mPointerX -> u
    float mPointerY -> v
    boolean mChanging -> w
    int mChoice -> x
    int mPreviousChoice -> y
    long mChoiceChangeTimestamp -> z
    us.blanshard.sudoku.core.Numeral mDefaultChoice -> A
    float[] TRAIL_X_CENTER -> B
    float[] TRAIL_Y_TOP -> C
    void setOnMoveListener(us.blanshard.sudoku.android.SudokuView$OnMoveListener) -> a
    void invalidateLocation(us.blanshard.sudoku.core.Location) -> c
    us.blanshard.sudoku.game.Sudoku getGame() -> d
    void setGame(us.blanshard.sudoku.game.Sudoku) -> a
    void setPuzzle(us.blanshard.sudoku.core.Grid) -> a
    void setPuzzleEditor(us.blanshard.sudoku.core.Grid) -> b
    void setEditable(boolean) -> a
    void setBrokenLocations(java.util.Collection) -> a
    void setTrails(java.util.List) -> a
    boolean isTrailActive() -> e
    void setTrailActive(boolean) -> b
    us.blanshard.sudoku.core.Numeral getDefaultChoice() -> f
    void setDefaultChoice(us.blanshard.sudoku.core.Numeral) -> a
    us.blanshard.sudoku.game.Sudoku$State getInputState() -> g
    void onMeasure(int,int) -> onMeasure
    void onDraw(android.graphics.Canvas) -> onDraw
    float calcRadians(int) -> a
    float calcToBaseline() -> h
    void drawChoice(int,android.graphics.Canvas,float,float) -> a
    boolean onTouchEvent(android.view.MotionEvent) -> onTouchEvent
    us.blanshard.sudoku.core.Location getLocation(float,float) -> a
    int findGridIndex(float,int[]) -> a
    void invalidateTouchPoint() -> a
    void invalidateCircle(float,float,float) -> a
us.blanshard.sudoku.android.SudokuView$OnMoveListener -> us.blanshard.sudoku.android.bc:
    void onMove(us.blanshard.sudoku.game.Sudoku$State,us.blanshard.sudoku.core.Location,us.blanshard.sudoku.core.Numeral) -> a
us.blanshard.sudoku.android.ToText -> us.blanshard.sudoku.android.bd:
    int[] $SWITCH_TABLE$us$blanshard$sudoku$android$Database$GameState -> a
    java.lang.String elapsedTime(long) -> a
    java.lang.CharSequence relativeDateTime(android.content.Context,long) -> a
    java.lang.String collectionNameHtml(android.content.Context,us.blanshard.sudoku.android.Database$Element,boolean) -> a
    java.lang.String collectionNameAndTimeHtml(android.content.Context,us.blanshard.sudoku.android.Database$Element) -> a
    java.lang.String gameSummaryHtml(android.content.Context,us.blanshard.sudoku.android.Database$Game,boolean) -> a
    int[] $SWITCH_TABLE$us$blanshard$sudoku$android$Database$GameState() -> a
us.blanshard.sudoku.android.TrailAdapter -> us.blanshard.sudoku.android.be:
    us.blanshard.sudoku.android.SudokuFragment mFragment -> a
    boolean mBuildingView -> b
    long getItemId(int) -> getItemId
    android.view.View getView(int,android.view.View,android.view.ViewGroup) -> getView
    void onCheckedChanged(android.widget.CompoundButton,boolean) -> onCheckedChanged
    us.blanshard.sudoku.android.SudokuFragment access$0(us.blanshard.sudoku.android.TrailAdapter) -> a
us.blanshard.sudoku.android.TrailAdapter$ViewHolder -> us.blanshard.sudoku.android.bf:
    android.view.View rowView -> a
    android.widget.TextView label -> b
    android.widget.TextView count -> c
    android.widget.CheckBox checkbox -> d
    us.blanshard.sudoku.android.TrailAdapter this$0 -> e
us.blanshard.sudoku.android.TrailItem -> us.blanshard.sudoku.android.bg:
    us.blanshard.sudoku.game.Sudoku$Trail trail -> a
    int color -> b
    int dimColor -> c
    boolean shown -> d
    boolean off -> e
    java.lang.String toString() -> toString
us.blanshard.sudoku.android.WorkerFragment -> us.blanshard.sudoku.android.bh:
    java.lang.String TAG -> a
    java.util.concurrent.ExecutorService sExecutor -> b
    android.os.Handler sHandler -> c
    java.util.Queue mDependentTasks -> d
    java.util.Queue mPendingForegroundJobs -> e
    us.blanshard.sudoku.android.WorkerFragment getWorker(android.app.Fragment) -> a
    us.blanshard.sudoku.android.WorkerFragment getWorker(android.app.Activity) -> a
    us.blanshard.sudoku.android.WorkerFragment getWorker(android.app.FragmentManager) -> a
    android.app.Fragment getFragment(java.lang.Class,int) -> a
    void runWhenAttached(us.blanshard.sudoku.android.WorkerFragment$BaseTask$Foreground) -> a
    void onCreate(android.os.Bundle) -> onCreate
    void onActivityCreated(android.os.Bundle) -> onActivityCreated
    void onDetach() -> onDetach
    java.lang.String access$0() -> a
    android.os.Handler access$1() -> b
    java.util.concurrent.ExecutorService access$2() -> c
    java.util.Queue access$3(us.blanshard.sudoku.android.WorkerFragment) -> a
us.blanshard.sudoku.android.WorkerFragment$1 -> us.blanshard.sudoku.android.bi:
    void handleMessage(android.os.Message) -> handleMessage
us.blanshard.sudoku.android.WorkerFragment$ActivityTask -> us.blanshard.sudoku.android.bj:
    us.blanshard.sudoku.android.WorkerFragment getTaskWorker(java.lang.Object) -> a
    java.lang.Object getAnchor() -> a
us.blanshard.sudoku.android.WorkerFragment$BaseTask -> us.blanshard.sudoku.android.bk:
    us.blanshard.sudoku.android.WorkerFragment mWorker -> b
    java.lang.Class mAnchorClass -> c
    us.blanshard.sudoku.android.WorkerFragment$Priority mPriority -> a
    us.blanshard.sudoku.android.WorkerFragment$Independence mIndependence -> d
    java.util.concurrent.Future mFuture -> e
    void execute(java.lang.Object[]) -> b
    void cancel() -> b
    boolean wasCanceled() -> c
    java.lang.Object doInBackground(java.lang.Object[]) -> a
    void publishProgress(java.lang.Object[]) -> c
    void onProgressUpdate(java.lang.Object,java.lang.Object[]) -> a
    void onPostExecute(java.lang.Object,java.lang.Object) -> a
    us.blanshard.sudoku.android.WorkerFragment getTaskWorker(java.lang.Object) -> a
    java.lang.Object getAnchor() -> a
    us.blanshard.sudoku.android.WorkerFragment$Priority access$0(us.blanshard.sudoku.android.WorkerFragment$BaseTask) -> a
us.blanshard.sudoku.android.WorkerFragment$BaseTask$1 -> us.blanshard.sudoku.android.bl:
    us.blanshard.sudoku.android.WorkerFragment$BaseTask this$1 -> a
    java.lang.Object[] val$inputs -> b
    void run() -> run
us.blanshard.sudoku.android.WorkerFragment$BaseTask$1$1 -> us.blanshard.sudoku.android.bm:
    us.blanshard.sudoku.android.WorkerFragment$BaseTask$1 this$2 -> a
    java.lang.Object val$output -> c
    void run() -> run
us.blanshard.sudoku.android.WorkerFragment$BaseTask$1$2 -> us.blanshard.sudoku.android.bn:
    us.blanshard.sudoku.android.WorkerFragment$BaseTask$1 this$2 -> a
    java.lang.Throwable val$t -> c
    void run() -> run
us.blanshard.sudoku.android.WorkerFragment$BaseTask$2 -> us.blanshard.sudoku.android.bo:
    us.blanshard.sudoku.android.WorkerFragment$BaseTask this$1 -> a
    java.lang.Object[] val$values -> c
    void run() -> run
us.blanshard.sudoku.android.WorkerFragment$BaseTask$Foreground -> us.blanshard.sudoku.android.bp:
    us.blanshard.sudoku.android.WorkerFragment$BaseTask this$1 -> b
    void runInForeground() -> a
us.blanshard.sudoku.android.WorkerFragment$Independence -> us.blanshard.sudoku.android.bq:
    us.blanshard.sudoku.android.WorkerFragment$Independence DEPENDENT -> a
    us.blanshard.sudoku.android.WorkerFragment$Independence FREE -> b
    us.blanshard.sudoku.android.WorkerFragment$Independence[] ENUM$VALUES -> c
    us.blanshard.sudoku.android.WorkerFragment$Independence[] values() -> values
    us.blanshard.sudoku.android.WorkerFragment$Independence valueOf(java.lang.String) -> valueOf
us.blanshard.sudoku.android.WorkerFragment$Priority -> us.blanshard.sudoku.android.br:
    us.blanshard.sudoku.android.WorkerFragment$Priority BACKGROUND -> a
    us.blanshard.sudoku.android.WorkerFragment$Priority FOREGROUND -> b
    int mThreadPriority -> c
    us.blanshard.sudoku.android.WorkerFragment$Priority[] ENUM$VALUES -> d
    us.blanshard.sudoku.android.WorkerFragment$Priority[] values() -> values
    us.blanshard.sudoku.android.WorkerFragment$Priority valueOf(java.lang.String) -> valueOf
us.blanshard.sudoku.android.WorkerFragment$Task -> us.blanshard.sudoku.android.bs:
    int mFragmentId -> a
    us.blanshard.sudoku.android.WorkerFragment getTaskWorker(java.lang.Object) -> a
    java.lang.Object getAnchor() -> a
us.blanshard.sudoku.core.Assignment -> us.blanshard.sudoku.a.a:
    us.blanshard.sudoku.core.Location location -> a
    us.blanshard.sudoku.core.Numeral numeral -> b
    us.blanshard.sudoku.core.Assignment of(us.blanshard.sudoku.core.Location,us.blanshard.sudoku.core.Numeral) -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
us.blanshard.sudoku.core.Block -> us.blanshard.sudoku.a.b:
    int number -> a
    int index -> b
    java.util.List ALL -> c
    us.blanshard.sudoku.core.Block[] instances -> e
    us.blanshard.sudoku.core.Block ofIndex(int) -> a
    us.blanshard.sudoku.core.Block ofIndices(int,int) -> a
    int rowIndex() -> a
    int columnIndex() -> b
    int unitIndex() -> c
    us.blanshard.sudoku.core.Unit$Type getType() -> d
    java.lang.String toString() -> toString
us.blanshard.sudoku.core.Column -> us.blanshard.sudoku.a.c:
    int number -> a
    int index -> b
    java.util.List ALL -> c
    us.blanshard.sudoku.core.Column[] instances -> e
    us.blanshard.sudoku.core.Column ofIndex(int) -> a
    int unitIndex() -> c
    us.blanshard.sudoku.core.Unit$Type getType() -> d
    java.lang.String toString() -> toString
us.blanshard.sudoku.core.Generator -> us.blanshard.sudoku.a.d:
    us.blanshard.sudoku.core.Generator SIMPLE -> a
    us.blanshard.sudoku.core.Generator SUBTRACTIVE -> b
    us.blanshard.sudoku.core.Generator SUBTRACTIVE_RANDOM -> c
    us.blanshard.sudoku.core.Generator[] ENUM$VALUES -> d
    us.blanshard.sudoku.core.Grid generate(java.util.Random,us.blanshard.sudoku.core.Symmetry,us.blanshard.sudoku.core.Grid) -> a
    us.blanshard.sudoku.core.Grid generate(java.util.Random,us.blanshard.sudoku.core.Symmetry) -> a
    us.blanshard.sudoku.core.Grid$Builder buildToMaximal(java.util.Random,us.blanshard.sudoku.core.Symmetry,us.blanshard.sudoku.core.Grid,java.util.List) -> a
    us.blanshard.sudoku.core.Grid subtract(java.util.Random,us.blanshard.sudoku.core.Symmetry,us.blanshard.sudoku.core.Grid$Builder,java.util.List) -> a
    us.blanshard.sudoku.core.Generator[] values() -> values
    us.blanshard.sudoku.core.Generator valueOf(java.lang.String) -> valueOf
us.blanshard.sudoku.core.Generator$1 -> us.blanshard.sudoku.a.e:
    us.blanshard.sudoku.core.Grid generate(java.util.Random,us.blanshard.sudoku.core.Symmetry,us.blanshard.sudoku.core.Grid) -> a
us.blanshard.sudoku.core.Generator$2 -> us.blanshard.sudoku.a.f:
    us.blanshard.sudoku.core.Grid generate(java.util.Random,us.blanshard.sudoku.core.Symmetry,us.blanshard.sudoku.core.Grid) -> a
us.blanshard.sudoku.core.Generator$3 -> us.blanshard.sudoku.a.g:
    us.blanshard.sudoku.core.Grid generate(java.util.Random,us.blanshard.sudoku.core.Symmetry,us.blanshard.sudoku.core.Grid) -> a
us.blanshard.sudoku.core.Grid -> us.blanshard.sudoku.a.h:
    byte[] squares -> b
    us.blanshard.sudoku.core.Grid BLANK -> a
    us.blanshard.sudoku.core.Grid$Builder builder() -> a
    us.blanshard.sudoku.core.Grid$Builder toBuilder() -> b
    java.util.Set getBrokenLocations() -> c
    void clear() -> clear
    boolean containsKey(java.lang.Object) -> containsKey
    boolean containsKey(us.blanshard.sudoku.core.Location) -> a
    boolean containsValue(java.lang.Object) -> containsValue
    java.util.Set entrySet() -> entrySet
    boolean equals(java.lang.Object) -> equals
    us.blanshard.sudoku.core.Numeral get(java.lang.Object) -> a
    us.blanshard.sudoku.core.Numeral get(us.blanshard.sudoku.core.Location) -> b
    int hashCode() -> hashCode
    int size() -> size
    java.lang.String toString() -> toString
    java.lang.String toFlatString() -> d
    us.blanshard.sudoku.core.Grid fromString(java.lang.String) -> a
    java.lang.Object get(java.lang.Object) -> get
    java.lang.Object remove(java.lang.Object) -> remove
    java.lang.Object put(java.lang.Object,java.lang.Object) -> put
    byte[] access$3(us.blanshard.sudoku.core.Grid) -> a
us.blanshard.sudoku.core.Grid$Builder -> us.blanshard.sudoku.a.i:
    us.blanshard.sudoku.core.Grid grid -> a
    boolean built -> b
    us.blanshard.sudoku.core.Grid grid() -> d
    us.blanshard.sudoku.core.Grid build() -> a
    us.blanshard.sudoku.core.Numeral get(us.blanshard.sudoku.core.Location) -> a
    us.blanshard.sudoku.core.Grid$Builder put(us.blanshard.sudoku.core.Location,us.blanshard.sudoku.core.Numeral) -> a
    us.blanshard.sudoku.core.Grid$Builder remove(us.blanshard.sudoku.core.Location) -> b
    us.blanshard.sudoku.core.Grid$Builder putAll(java.util.Collection) -> a
    int size() -> b
    java.util.Set entrySet() -> c
us.blanshard.sudoku.core.Grid$EntrySet -> us.blanshard.sudoku.a.j:
    us.blanshard.sudoku.core.Grid this$0 -> a
    boolean addAll(java.util.Collection) -> addAll
    void clear() -> clear
    boolean contains(java.lang.Object) -> contains
    boolean isEmpty() -> isEmpty
    java.util.Iterator iterator() -> iterator
    boolean remove(java.lang.Object) -> remove
    int size() -> size
    boolean add(java.lang.Object) -> add
us.blanshard.sudoku.core.Grid$GridEntry -> us.blanshard.sudoku.a.k:
    int index -> b
    us.blanshard.sudoku.core.Grid this$0 -> a
    us.blanshard.sudoku.core.Numeral getValue() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    java.lang.Object getValue() -> getValue
    java.lang.Object getKey() -> getKey
    java.lang.Object setValue(java.lang.Object) -> setValue
us.blanshard.sudoku.core.Grid$Iter -> us.blanshard.sudoku.a.l:
    int nextIndex -> b
    us.blanshard.sudoku.core.Grid this$0 -> a
    boolean hasNext() -> hasNext
    void stepIndex() -> a
    void remove() -> remove
    java.lang.Object next() -> next
us.blanshard.sudoku.core.Grid$State -> us.blanshard.sudoku.a.m:
    us.blanshard.sudoku.core.Grid$State INCOMPLETE -> a
    us.blanshard.sudoku.core.Grid$State BROKEN -> b
    us.blanshard.sudoku.core.Grid$State SOLVED -> c
    us.blanshard.sudoku.core.Grid$State[] ENUM$VALUES -> d
    us.blanshard.sudoku.core.Grid$State[] values() -> values
    us.blanshard.sudoku.core.Grid$State valueOf(java.lang.String) -> valueOf
us.blanshard.sudoku.core.LocSet -> us.blanshard.sudoku.a.n:
    long bits0 -> a
    long bits1 -> b
    int size -> c
    us.blanshard.sudoku.core.LocSet all() -> a
    us.blanshard.sudoku.core.LocSet and(java.util.Collection) -> a
    us.blanshard.sudoku.core.LocSet minus(java.util.Collection) -> b
    us.blanshard.sudoku.core.LocSet clone() -> b
    boolean contains(us.blanshard.sudoku.core.Location) -> a
    boolean contains(java.lang.Object) -> contains
    java.util.Iterator iterator() -> iterator
    int size() -> size
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean remove(us.blanshard.sudoku.core.Location) -> b
    boolean remove(java.lang.Object) -> remove
    boolean containsAll(java.util.Collection) -> containsAll
    boolean addAll(java.util.Collection) -> addAll
    boolean removeAll(java.util.Collection) -> removeAll
    boolean retainAll(java.util.Collection) -> retainAll
    void clear() -> clear
    long bits(us.blanshard.sudoku.core.Location) -> c
    void setBits(us.blanshard.sudoku.core.Location,long) -> a
    boolean fixSize() -> c
    java.lang.Object clone() -> clone
    boolean add(java.lang.Object) -> add
    long access$2(us.blanshard.sudoku.core.LocSet) -> a
    long access$3(us.blanshard.sudoku.core.LocSet) -> b
us.blanshard.sudoku.core.LocSet$Iter -> us.blanshard.sudoku.a.o:
    long remaining -> b
    boolean zeroDone -> c
    us.blanshard.sudoku.core.Location last -> d
    us.blanshard.sudoku.core.LocSet this$0 -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
us.blanshard.sudoku.core.Location -> us.blanshard.sudoku.a.p:
    us.blanshard.sudoku.core.Row row -> a
    us.blanshard.sudoku.core.Column column -> b
    us.blanshard.sudoku.core.Block block -> c
    java.util.Map unitSubsets -> d
    java.util.List peers -> e
    int index -> f
    java.util.List ALL -> g
    us.blanshard.sudoku.core.Location[] peersArray -> h
    us.blanshard.sudoku.core.Location[] instances -> i
    us.blanshard.sudoku.core.Location of(us.blanshard.sudoku.core.Row,us.blanshard.sudoku.core.Column) -> a
    us.blanshard.sudoku.core.Location of(int,int) -> a
    us.blanshard.sudoku.core.Location ofIndices(int,int) -> b
    us.blanshard.sudoku.core.Location of(int) -> a
    us.blanshard.sudoku.core.Unit unit(us.blanshard.sudoku.core.Unit$Type) -> a
    java.lang.String toString() -> toString
    java.util.Iterator iterator(byte[]) -> a
    int compareTo(java.lang.Object) -> compareTo
us.blanshard.sudoku.core.Location$Iter -> us.blanshard.sudoku.a.q:
    byte[] indices -> a
    int next -> b
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
us.blanshard.sudoku.core.Marks -> us.blanshard.sudoku.a.r:
    short[] bits -> a
    short[] unitBits -> b
    us.blanshard.sudoku.core.Marks$Builder builder() -> a
    us.blanshard.sudoku.core.Marks$Builder toBuilder() -> b
    us.blanshard.sudoku.core.Grid toGrid() -> c
    us.blanshard.sudoku.core.NumSet get(us.blanshard.sudoku.core.Location) -> a
    int getBits(us.blanshard.sudoku.core.Location) -> b
    us.blanshard.sudoku.core.UnitSubset get(us.blanshard.sudoku.core.Unit,us.blanshard.sudoku.core.Numeral) -> a
    int getBits(us.blanshard.sudoku.core.Unit,us.blanshard.sudoku.core.Numeral) -> b
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    java.lang.StringBuilder append(us.blanshard.sudoku.core.NumSet,int,java.lang.StringBuilder) -> a
    java.lang.StringBuilder append(char,int,java.lang.StringBuilder) -> a
    short[] access$1(us.blanshard.sudoku.core.Marks) -> a
    short[] access$2(us.blanshard.sudoku.core.Marks) -> b
us.blanshard.sudoku.core.Marks$Builder -> us.blanshard.sudoku.a.s:
    us.blanshard.sudoku.core.Marks marks -> a
    boolean built -> b
    us.blanshard.sudoku.core.Marks marks() -> b
    us.blanshard.sudoku.core.Marks build() -> a
    us.blanshard.sudoku.core.NumSet get(us.blanshard.sudoku.core.Location) -> a
    boolean assign(us.blanshard.sudoku.core.Location,us.blanshard.sudoku.core.Numeral) -> a
    boolean eliminate(us.blanshard.sudoku.core.Location,us.blanshard.sudoku.core.Numeral) -> b
    boolean assignAll(java.util.Map) -> a
    boolean assignRecursively(us.blanshard.sudoku.core.Location,us.blanshard.sudoku.core.Numeral) -> c
    boolean assignAllRecursively(java.util.Map) -> b
    boolean eliminateRecursively(us.blanshard.sudoku.core.Location,us.blanshard.sudoku.core.Numeral) -> d
us.blanshard.sudoku.core.NumSet -> us.blanshard.sudoku.a.t:
    short bits -> a
    byte[] nums -> d
    us.blanshard.sudoku.core.NumSet NONE -> b
    us.blanshard.sudoku.core.NumSet ALL -> c
    us.blanshard.sudoku.core.NumSet[] instances -> e
    us.blanshard.sudoku.core.NumSet ofBits(int) -> a
    us.blanshard.sudoku.core.NumSet with(us.blanshard.sudoku.core.Numeral) -> a
    us.blanshard.sudoku.core.NumSet without(us.blanshard.sudoku.core.Numeral) -> b
    us.blanshard.sudoku.core.NumSet not() -> a
    us.blanshard.sudoku.core.NumSet and(us.blanshard.sudoku.core.NumSet) -> a
    us.blanshard.sudoku.core.NumSet or(us.blanshard.sudoku.core.NumSet) -> b
    us.blanshard.sudoku.core.NumSet minus(us.blanshard.sudoku.core.NumSet) -> c
    boolean isSubsetOf(us.blanshard.sudoku.core.NumSet) -> d
    boolean contains(us.blanshard.sudoku.core.Numeral) -> c
    boolean contains(java.lang.Object) -> contains
    us.blanshard.sudoku.core.Numeral get(int) -> b
    java.util.Iterator iterator() -> iterator
    int size() -> size
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    byte[] access$0(us.blanshard.sudoku.core.NumSet) -> e
us.blanshard.sudoku.core.NumSet$Iter -> us.blanshard.sudoku.a.u:
    int nextIndex -> b
    us.blanshard.sudoku.core.NumSet this$0 -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
us.blanshard.sudoku.core.Numeral -> us.blanshard.sudoku.a.v:
    int number -> a
    int index -> b
    short bit -> c
    java.util.List ALL -> d
    us.blanshard.sudoku.core.Numeral[] instances -> e
    us.blanshard.sudoku.core.Numeral of(int) -> a
    us.blanshard.sudoku.core.Numeral numeral(int) -> b
    int number(us.blanshard.sudoku.core.Numeral) -> a
    us.blanshard.sudoku.core.NumSet asSet() -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int compareTo(java.lang.Object) -> compareTo
us.blanshard.sudoku.core.Row -> us.blanshard.sudoku.a.w:
    int number -> a
    int index -> b
    java.util.List ALL -> c
    us.blanshard.sudoku.core.Row[] instances -> e
    us.blanshard.sudoku.core.Row ofIndex(int) -> a
    int unitIndex() -> c
    us.blanshard.sudoku.core.Unit$Type getType() -> d
    java.lang.String toString() -> toString
us.blanshard.sudoku.core.Solver -> us.blanshard.sudoku.a.x:
    us.blanshard.sudoku.core.Grid start -> a
    java.util.Random random -> b
    us.blanshard.sudoku.core.Solver$Strategy strategy -> c
    us.blanshard.sudoku.core.Marks startMarks -> d
    us.blanshard.sudoku.core.Location[] locations -> e
    us.blanshard.sudoku.core.Solver$Result solve(us.blanshard.sudoku.core.Grid) -> a
    us.blanshard.sudoku.core.Solver$Result solve(us.blanshard.sudoku.core.Grid,java.util.Random) -> a
    us.blanshard.sudoku.core.Solver$Iter iterator() -> a
    us.blanshard.sudoku.core.Solver$Iter makeIterator$591d2bd(int,int) -> a
    java.util.Iterator iterator() -> iterator
    us.blanshard.sudoku.core.Grid access$1(us.blanshard.sudoku.core.Solver) -> a
    us.blanshard.sudoku.core.Marks access$2(us.blanshard.sudoku.core.Solver) -> b
    us.blanshard.sudoku.core.Location[] access$3(us.blanshard.sudoku.core.Solver) -> c
    java.util.Random access$4(us.blanshard.sudoku.core.Solver) -> d
    us.blanshard.sudoku.core.Solver$WorkItem[] access$5(us.blanshard.sudoku.core.Marks,us.blanshard.sudoku.core.Location) -> a
us.blanshard.sudoku.core.Solver$Iter -> us.blanshard.sudoku.a.y:
    boolean nextComputed -> b
    us.blanshard.sudoku.core.Grid next -> c
    int stepCount -> d
    us.blanshard.sudoku.core.Solver$Worklist worklist -> e
    us.blanshard.sudoku.core.Solver this$0 -> a
    int getStepCount() -> a
    boolean hasNext() -> hasNext
    us.blanshard.sudoku.core.Grid next() -> b
    void remove() -> remove
    java.lang.Object next() -> next
us.blanshard.sudoku.core.Solver$Result -> us.blanshard.sudoku.a.z:
    us.blanshard.sudoku.core.Grid start -> a
    int numSolutions -> b
    int numSteps -> c
    int numStepsAfterSolution -> d
    us.blanshard.sudoku.core.Grid solution -> e
    us.blanshard.sudoku.core.Solver this$0 -> f
us.blanshard.sudoku.core.Solver$Strategy -> us.blanshard.sudoku.a.aa:
    us.blanshard.sudoku.core.Solver$Strategy SIMPLE -> a
    us.blanshard.sudoku.core.Solver$Strategy FAST -> b
    us.blanshard.sudoku.core.Solver$Strategy[] ENUM$VALUES -> c
    us.blanshard.sudoku.core.Solver$Iter getIterator(us.blanshard.sudoku.core.Solver) -> a
    us.blanshard.sudoku.core.Solver$Strategy[] values() -> values
    us.blanshard.sudoku.core.Solver$Strategy valueOf(java.lang.String) -> valueOf
us.blanshard.sudoku.core.Solver$Strategy$1 -> us.blanshard.sudoku.a.ab:
    us.blanshard.sudoku.core.Solver$Iter getIterator(us.blanshard.sudoku.core.Solver) -> a
us.blanshard.sudoku.core.Solver$Strategy$2 -> us.blanshard.sudoku.a.ac:
    us.blanshard.sudoku.core.Solver$Iter getIterator(us.blanshard.sudoku.core.Solver) -> a
us.blanshard.sudoku.core.Solver$WorkItem -> us.blanshard.sudoku.a.ad:
    us.blanshard.sudoku.core.Marks marks -> a
    us.blanshard.sudoku.core.Location location -> b
    us.blanshard.sudoku.core.Numeral numeral -> c
us.blanshard.sudoku.core.Solver$Worklist -> us.blanshard.sudoku.a.ae:
    us.blanshard.sudoku.core.Grid found -> b
    java.util.ArrayDeque worklist -> c
    us.blanshard.sudoku.core.Location[] locations -> d
    us.blanshard.sudoku.core.Solver this$0 -> a
    us.blanshard.sudoku.core.Grid getFound() -> a
    boolean isComplete() -> b
    boolean isCompleteOrFoundSomething() -> c
    int run(int) -> a
    boolean pushNextItems(us.blanshard.sudoku.core.Marks) -> a
us.blanshard.sudoku.core.Symmetry -> us.blanshard.sudoku.a.af:
    us.blanshard.sudoku.core.Symmetry RANDOM -> a
    us.blanshard.sudoku.core.Symmetry CLASSIC -> b
    us.blanshard.sudoku.core.Symmetry MIRROR -> c
    us.blanshard.sudoku.core.Symmetry DOUBLE_MIRROR -> d
    us.blanshard.sudoku.core.Symmetry DIAGONAL -> e
    us.blanshard.sudoku.core.Symmetry ROTATIONAL -> f
    us.blanshard.sudoku.core.Symmetry BLOCKWISE -> g
    us.blanshard.sudoku.core.Symmetry[] values -> h
    us.blanshard.sudoku.core.Symmetry[] ENUM$VALUES -> i
    java.lang.Iterable expand(us.blanshard.sudoku.core.Location) -> a
    us.blanshard.sudoku.core.Symmetry[] values() -> values
    us.blanshard.sudoku.core.Symmetry valueOf(java.lang.String) -> valueOf
us.blanshard.sudoku.core.Symmetry$1 -> us.blanshard.sudoku.a.ag:
    java.lang.Iterable expand(us.blanshard.sudoku.core.Location) -> a
us.blanshard.sudoku.core.Symmetry$2 -> us.blanshard.sudoku.a.ah:
    java.lang.Iterable expand(us.blanshard.sudoku.core.Location) -> a
us.blanshard.sudoku.core.Symmetry$3 -> us.blanshard.sudoku.a.ai:
    java.lang.Iterable expand(us.blanshard.sudoku.core.Location) -> a
us.blanshard.sudoku.core.Symmetry$4 -> us.blanshard.sudoku.a.aj:
    java.lang.Iterable expand(us.blanshard.sudoku.core.Location) -> a
us.blanshard.sudoku.core.Symmetry$5 -> us.blanshard.sudoku.a.ak:
    java.lang.Iterable expand(us.blanshard.sudoku.core.Location) -> a
us.blanshard.sudoku.core.Symmetry$6 -> us.blanshard.sudoku.a.al:
    java.lang.Iterable expand(us.blanshard.sudoku.core.Location) -> a
us.blanshard.sudoku.core.Symmetry$7 -> us.blanshard.sudoku.a.am:
    java.lang.Iterable expand(us.blanshard.sudoku.core.Location) -> a
us.blanshard.sudoku.core.Unit -> us.blanshard.sudoku.a.an:
    byte[] locations -> d
    java.util.List allUnits() -> e
    us.blanshard.sudoku.core.UnitSubset intersect(java.util.Collection) -> a
    int unitIndex() -> c
    us.blanshard.sudoku.core.Unit$Type getType() -> d
    boolean contains(us.blanshard.sudoku.core.Location) -> a
    us.blanshard.sudoku.core.Location get(int) -> b
    int size() -> size
    boolean contains(java.lang.Object) -> contains
    java.util.Iterator iterator() -> iterator
    int compareTo(java.lang.Object) -> compareTo
us.blanshard.sudoku.core.Unit$AllUnits -> us.blanshard.sudoku.a.ao:
    us.blanshard.sudoku.core.Unit$AllUnits INSTANCE -> a
    java.util.List list -> b
    us.blanshard.sudoku.core.Unit$AllUnits[] ENUM$VALUES -> c
    us.blanshard.sudoku.core.Unit$AllUnits[] values() -> values
    us.blanshard.sudoku.core.Unit$AllUnits valueOf(java.lang.String) -> valueOf
    java.util.List access$2(us.blanshard.sudoku.core.Unit$AllUnits) -> a
us.blanshard.sudoku.core.Unit$Type -> us.blanshard.sudoku.a.ap:
    us.blanshard.sudoku.core.Unit$Type ROW -> a
    us.blanshard.sudoku.core.Unit$Type COLUMN -> b
    us.blanshard.sudoku.core.Unit$Type BLOCK -> c
    us.blanshard.sudoku.core.Unit$Type[] ENUM$VALUES -> d
    us.blanshard.sudoku.core.Unit$Type[] values() -> values
    us.blanshard.sudoku.core.Unit$Type valueOf(java.lang.String) -> valueOf
us.blanshard.sudoku.core.UnitSubset -> us.blanshard.sudoku.a.aq:
    us.blanshard.sudoku.core.Unit unit -> a
    short bits -> b
    us.blanshard.sudoku.core.NumSet set -> c
    us.blanshard.sudoku.core.UnitSubset ofBits(us.blanshard.sudoku.core.Unit,int) -> a
    us.blanshard.sudoku.core.UnitSubset of(us.blanshard.sudoku.core.Unit,us.blanshard.sudoku.core.Location[]) -> a
    us.blanshard.sudoku.core.UnitSubset singleton(us.blanshard.sudoku.core.Unit,us.blanshard.sudoku.core.Location) -> a
    us.blanshard.sudoku.core.UnitSubset with(us.blanshard.sudoku.core.Location) -> a
    us.blanshard.sudoku.core.UnitSubset not() -> a
    us.blanshard.sudoku.core.UnitSubset or(java.lang.Iterable) -> a
    us.blanshard.sudoku.core.UnitSubset minus(java.lang.Iterable) -> b
    boolean isSubsetOf(java.lang.Iterable) -> c
    boolean contains(us.blanshard.sudoku.core.Location) -> b
    boolean contains(java.lang.Object) -> contains
    us.blanshard.sudoku.core.Location get(int) -> a
    int getIndex(int) -> b
    java.util.Iterator iterator() -> iterator
    int size() -> size
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    us.blanshard.sudoku.core.UnitSubset sameUnit(java.lang.Iterable) -> d
    us.blanshard.sudoku.core.NumSet access$0(us.blanshard.sudoku.core.UnitSubset) -> a
us.blanshard.sudoku.core.UnitSubset$Iter -> us.blanshard.sudoku.a.ar:
    java.util.Iterator setIter -> b
    us.blanshard.sudoku.core.UnitSubset this$0 -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
us.blanshard.sudoku.game.Command -> us.blanshard.sudoku.b.a:
    void redo() -> a
    void undo() -> b
    java.lang.String toJsonValue() -> c
us.blanshard.sudoku.game.CommandException -> us.blanshard.sudoku.b.b:
us.blanshard.sudoku.game.GameJson -> us.blanshard.sudoku.b.c:
    com.google.common.base.Splitter SPLITTER -> a
    com.google.common.base.Joiner JOINER -> b
    org.json.JSONArray fromHistory(java.util.List) -> a
    java.util.List toHistory(java.lang.String) -> a
    org.json.JSONObject fromUndoStack(us.blanshard.sudoku.game.UndoStack) -> a
    us.blanshard.sudoku.game.UndoStack toUndoStack(org.json.JSONObject,us.blanshard.sudoku.game.Sudoku) -> a
us.blanshard.sudoku.game.Move -> us.blanshard.sudoku.b.d:
    long timestamp -> a
    int trailId -> b
    us.blanshard.sudoku.game.MoveCommand toCommand(us.blanshard.sudoku.game.Sudoku) -> a
    boolean apply(us.blanshard.sudoku.game.Sudoku) -> b
    java.lang.String toJsonValue() -> a
    us.blanshard.sudoku.core.Location getLocation() -> b
    us.blanshard.sudoku.core.Assignment getAssignment() -> c
us.blanshard.sudoku.game.Move$Clear -> us.blanshard.sudoku.b.e:
    us.blanshard.sudoku.core.Location loc -> c
    us.blanshard.sudoku.game.MoveCommand toCommand(us.blanshard.sudoku.game.Sudoku) -> a
    boolean apply(us.blanshard.sudoku.game.Sudoku) -> b
    java.lang.String toJsonValue() -> a
    us.blanshard.sudoku.core.Location getLocation() -> b
    us.blanshard.sudoku.core.Assignment getAssignment() -> c
us.blanshard.sudoku.game.Move$Set -> us.blanshard.sudoku.b.f:
    us.blanshard.sudoku.core.Location loc -> c
    us.blanshard.sudoku.core.Numeral num -> d
    us.blanshard.sudoku.game.MoveCommand toCommand(us.blanshard.sudoku.game.Sudoku) -> a
    boolean apply(us.blanshard.sudoku.game.Sudoku) -> b
    java.lang.String toJsonValue() -> a
    us.blanshard.sudoku.core.Location getLocation() -> b
    us.blanshard.sudoku.core.Assignment getAssignment() -> c
us.blanshard.sudoku.game.MoveCommand -> us.blanshard.sudoku.b.g:
    us.blanshard.sudoku.game.Sudoku$State state -> a
    us.blanshard.sudoku.core.Location loc -> b
    us.blanshard.sudoku.core.Numeral num -> c
    us.blanshard.sudoku.core.Numeral prevNum -> d
    us.blanshard.sudoku.core.Location getLocation() -> d
    void redo() -> a
    void undo() -> b
    java.lang.String toJsonValue() -> c
    void set(us.blanshard.sudoku.core.Numeral) -> a
us.blanshard.sudoku.game.Sudoku -> us.blanshard.sudoku.b.h:
    us.blanshard.sudoku.core.Grid puzzle -> a
    us.blanshard.sudoku.game.Sudoku$Registry registry -> b
    java.util.List history -> c
    long initialMillis -> d
    com.google.common.base.Stopwatch stopwatch -> e
    us.blanshard.sudoku.game.Sudoku$State state -> f
    java.util.List trails -> g
    us.blanshard.sudoku.game.Sudoku$Listener NULL_LISTENER -> h
    us.blanshard.sudoku.game.Sudoku$Registry NULL_REGISTRY -> i
    us.blanshard.sudoku.core.Grid getPuzzle() -> a
    us.blanshard.sudoku.game.Sudoku$Registry newRegistry() -> b
    java.util.List getHistory() -> c
    long elapsedMillis() -> d
    boolean isRunning() -> e
    us.blanshard.sudoku.game.Sudoku suspend() -> f
    us.blanshard.sudoku.game.Sudoku resume() -> g
    us.blanshard.sudoku.game.Sudoku$State getState() -> h
    us.blanshard.sudoku.game.Sudoku$State getState(int) -> a
    us.blanshard.sudoku.game.Sudoku$Trail getTrail(int) -> b
    int getNumTrails() -> i
    boolean move(us.blanshard.sudoku.game.Move) -> a
    boolean isFull() -> j
    us.blanshard.sudoku.core.Grid access$0(us.blanshard.sudoku.game.Sudoku) -> a
    us.blanshard.sudoku.game.Sudoku$State access$1(us.blanshard.sudoku.game.Sudoku) -> b
    us.blanshard.sudoku.game.Sudoku$Listener access$2() -> k
us.blanshard.sudoku.game.Sudoku$Adapter -> us.blanshard.sudoku.b.i:
    void gameCreated(us.blanshard.sudoku.game.Sudoku) -> b
    void gameSuspended(us.blanshard.sudoku.game.Sudoku) -> c
    void gameResumed(us.blanshard.sudoku.game.Sudoku) -> a
    void moveMade(us.blanshard.sudoku.game.Sudoku,us.blanshard.sudoku.game.Move) -> a
    void trailCreated(us.blanshard.sudoku.game.Sudoku,us.blanshard.sudoku.game.Sudoku$Trail) -> a
us.blanshard.sudoku.game.Sudoku$Listener -> us.blanshard.sudoku.b.j:
    void gameCreated(us.blanshard.sudoku.game.Sudoku) -> b
    void gameSuspended(us.blanshard.sudoku.game.Sudoku) -> c
    void gameResumed(us.blanshard.sudoku.game.Sudoku) -> a
    void moveMade(us.blanshard.sudoku.game.Sudoku,us.blanshard.sudoku.game.Move) -> a
    void trailCreated(us.blanshard.sudoku.game.Sudoku,us.blanshard.sudoku.game.Sudoku$Trail) -> a
us.blanshard.sudoku.game.Sudoku$NormalRegistry -> us.blanshard.sudoku.b.k:
    java.util.List listeners -> a
    void addListener(us.blanshard.sudoku.game.Sudoku$Listener) -> a
    us.blanshard.sudoku.game.Sudoku$Listener asListener() -> a
    void gameCreated(us.blanshard.sudoku.game.Sudoku) -> b
    void gameSuspended(us.blanshard.sudoku.game.Sudoku) -> c
    void gameResumed(us.blanshard.sudoku.game.Sudoku) -> a
    void moveMade(us.blanshard.sudoku.game.Sudoku,us.blanshard.sudoku.game.Move) -> a
    void trailCreated(us.blanshard.sudoku.game.Sudoku,us.blanshard.sudoku.game.Sudoku$Trail) -> a
us.blanshard.sudoku.game.Sudoku$NullRegistry -> us.blanshard.sudoku.b.l:
    void addListener(us.blanshard.sudoku.game.Sudoku$Listener) -> a
    us.blanshard.sudoku.game.Sudoku$Listener asListener() -> a
us.blanshard.sudoku.game.Sudoku$Registry -> us.blanshard.sudoku.b.m:
    void addListener(us.blanshard.sudoku.game.Sudoku$Listener) -> a
    us.blanshard.sudoku.game.Sudoku$Listener asListener() -> a
us.blanshard.sudoku.game.Sudoku$State -> us.blanshard.sudoku.b.n:
    us.blanshard.sudoku.core.Grid$Builder gridBuilder -> a
    us.blanshard.sudoku.game.Sudoku this$0 -> b
    int getId() -> a
    us.blanshard.sudoku.core.Numeral get(us.blanshard.sudoku.core.Location) -> a
    us.blanshard.sudoku.core.Grid getGrid() -> b
    int getSetCount() -> c
    boolean set(us.blanshard.sudoku.core.Location,us.blanshard.sudoku.core.Numeral) -> a
    boolean canModify(us.blanshard.sudoku.core.Location) -> b
    boolean actuallySet(us.blanshard.sudoku.core.Location,us.blanshard.sudoku.core.Numeral) -> b
    boolean actuallyClear(us.blanshard.sudoku.core.Location) -> c
us.blanshard.sudoku.game.Sudoku$Trail -> us.blanshard.sudoku.b.o:
    int id -> d
    us.blanshard.sudoku.core.Location first -> e
    us.blanshard.sudoku.game.Sudoku this$0 -> c
    int getId() -> a
    us.blanshard.sudoku.core.Grid getGrid() -> b
    us.blanshard.sudoku.core.Location getTrailhead() -> d
    boolean set(us.blanshard.sudoku.core.Location,us.blanshard.sudoku.core.Numeral) -> a
    boolean canModify(us.blanshard.sudoku.core.Location) -> b
    boolean actuallySet(us.blanshard.sudoku.core.Location,us.blanshard.sudoku.core.Numeral) -> b
    boolean actuallyClear(us.blanshard.sudoku.core.Location) -> c
us.blanshard.sudoku.game.UndoStack -> us.blanshard.sudoku.b.p:
    java.util.List commands -> a
    int position -> b
    int getPosition() -> a
    us.blanshard.sudoku.game.Command getLastCommand(boolean) -> a
    void doCommand(us.blanshard.sudoku.game.Command) -> a
    boolean canUndo() -> b
    void undo() -> c
    boolean canRedo() -> d
    void redo() -> e
us.blanshard.sudoku.insight.Analyzer -> us.blanshard.sudoku.c.a:
    int[] OVERLAP_BITS -> a
    int[] OVERLAP_BITS_2 -> b
    int[] $SWITCH_TABLE$us$blanshard$sudoku$insight$Insight$Type -> c
    boolean analyze(us.blanshard.sudoku.insight.GridMarks,us.blanshard.sudoku.insight.Analyzer$Callback) -> a
    us.blanshard.sudoku.insight.Insight minimize(us.blanshard.sudoku.insight.GridMarks,us.blanshard.sudoku.insight.Insight) -> a
    void findInsights(us.blanshard.sudoku.insight.GridMarks,us.blanshard.sudoku.insight.Analyzer$Callback,java.util.Set) -> a
    us.blanshard.sudoku.insight.Insight minimizeImplication(us.blanshard.sudoku.insight.GridMarks,us.blanshard.sudoku.insight.Implication) -> a
    boolean mayBeAntecedentTo(us.blanshard.sudoku.insight.Insight,us.blanshard.sudoku.insight.Insight) -> a
    void firstSubset(int,int[]) -> a
    boolean nextSubset(int,int[],int) -> a
    void checkInterruption() -> a
    void findOverlaps(us.blanshard.sudoku.insight.GridMarks,us.blanshard.sudoku.insight.Analyzer$Callback,us.blanshard.sudoku.core.Numeral,java.util.List,us.blanshard.sudoku.core.Unit$Type,int[]) -> a
    int[] $SWITCH_TABLE$us$blanshard$sudoku$insight$Insight$Type() -> b
us.blanshard.sudoku.insight.Analyzer$Callback -> us.blanshard.sudoku.c.b:
    void take(us.blanshard.sudoku.insight.Insight) -> a
us.blanshard.sudoku.insight.Analyzer$Collector -> us.blanshard.sudoku.c.c:
    us.blanshard.sudoku.insight.Analyzer$Callback delegate -> a
    java.util.Set index -> b
    java.util.List list -> c
    void take(us.blanshard.sudoku.insight.Insight) -> a
us.blanshard.sudoku.insight.Analyzer$SetState -> us.blanshard.sudoku.c.d:
    java.util.Map nums -> a
    java.util.Map locs -> b
    us.blanshard.sudoku.core.NumSet getNums(us.blanshard.sudoku.core.Unit) -> a
    us.blanshard.sudoku.core.UnitSubset getLocs(us.blanshard.sudoku.core.Unit) -> b
    void add(us.blanshard.sudoku.core.NumSet,us.blanshard.sudoku.core.UnitSubset) -> a
us.blanshard.sudoku.insight.Analyzer$StopException -> us.blanshard.sudoku.c.e:
us.blanshard.sudoku.insight.BarredLoc -> us.blanshard.sudoku.c.f:
    us.blanshard.sudoku.core.Location location -> b
    us.blanshard.sudoku.core.Location getLocation() -> a
    void apply(us.blanshard.sudoku.insight.GridMarks$Builder) -> a
    boolean isImpliedBy(us.blanshard.sudoku.insight.GridMarks) -> a
    boolean mightBeRevealedByElimination(us.blanshard.sudoku.core.Assignment) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
us.blanshard.sudoku.insight.BarredNum -> us.blanshard.sudoku.c.g:
    us.blanshard.sudoku.core.Unit unit -> b
    us.blanshard.sudoku.core.Numeral numeral -> c
    us.blanshard.sudoku.core.Unit getUnit() -> a
    us.blanshard.sudoku.core.Numeral getNumeral() -> b
    void apply(us.blanshard.sudoku.insight.GridMarks$Builder) -> a
    boolean isImpliedBy(us.blanshard.sudoku.insight.GridMarks) -> a
    boolean mightBeRevealedByElimination(us.blanshard.sudoku.core.Assignment) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
us.blanshard.sudoku.insight.Conflict -> us.blanshard.sudoku.c.h:
    us.blanshard.sudoku.core.Numeral numeral -> b
    us.blanshard.sudoku.core.UnitSubset locations -> c
    us.blanshard.sudoku.core.UnitSubset getLocations() -> a
    void apply(us.blanshard.sudoku.insight.GridMarks$Builder) -> a
    boolean isImpliedBy(us.blanshard.sudoku.insight.GridMarks) -> a
    boolean mightBeRevealedByElimination(us.blanshard.sudoku.core.Assignment) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
us.blanshard.sudoku.insight.DisprovedAssignment -> us.blanshard.sudoku.c.i:
    us.blanshard.sudoku.core.Assignment assignment -> b
    us.blanshard.sudoku.insight.Insight resultingError -> c
    us.blanshard.sudoku.core.Assignment getDisprovedAssignment() -> a
    us.blanshard.sudoku.insight.UnfoundedAssignment getUnfoundedAssignment() -> b
    us.blanshard.sudoku.insight.Insight getResultingError() -> c
    java.util.Collection getEliminations() -> d
    us.blanshard.sudoku.insight.Insight getNub() -> e
    int getDepth() -> f
    int getCount() -> g
    java.lang.String toShortString() -> h
    void apply(us.blanshard.sudoku.insight.GridMarks$Builder) -> a
    boolean isImpliedBy(us.blanshard.sudoku.insight.GridMarks) -> a
    boolean mightBeRevealedByElimination(us.blanshard.sudoku.core.Assignment) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    java.lang.String getPrefix() -> j
us.blanshard.sudoku.insight.ForcedLoc -> us.blanshard.sudoku.c.j:
    us.blanshard.sudoku.core.Unit unit -> b
    us.blanshard.sudoku.core.Numeral numeral -> c
    us.blanshard.sudoku.core.Location location -> d
    us.blanshard.sudoku.core.Unit getUnit() -> a
    us.blanshard.sudoku.core.Numeral getNumeral() -> b
    us.blanshard.sudoku.core.Location getLocation() -> c
    us.blanshard.sudoku.core.Assignment getImpliedAssignment() -> i
    void apply(us.blanshard.sudoku.insight.GridMarks$Builder) -> a
    boolean isImpliedBy(us.blanshard.sudoku.insight.GridMarks) -> a
    boolean mightBeRevealedByElimination(us.blanshard.sudoku.core.Assignment) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
us.blanshard.sudoku.insight.ForcedNum -> us.blanshard.sudoku.c.k:
    us.blanshard.sudoku.core.Location location -> b
    us.blanshard.sudoku.core.Numeral numeral -> c
    us.blanshard.sudoku.core.Location getLocation() -> a
    us.blanshard.sudoku.core.Numeral getNumeral() -> b
    us.blanshard.sudoku.core.Assignment getImpliedAssignment() -> i
    void apply(us.blanshard.sudoku.insight.GridMarks$Builder) -> a
    boolean isImpliedBy(us.blanshard.sudoku.insight.GridMarks) -> a
    boolean mightBeRevealedByElimination(us.blanshard.sudoku.core.Assignment) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
us.blanshard.sudoku.insight.GridMarks -> us.blanshard.sudoku.c.l:
    us.blanshard.sudoku.core.Grid grid -> a
    us.blanshard.sudoku.core.Marks marks -> b
    boolean hasErrors -> c
    us.blanshard.sudoku.insight.GridMarks$Builder toBuilder() -> a
us.blanshard.sudoku.insight.GridMarks$Builder -> us.blanshard.sudoku.c.m:
    us.blanshard.sudoku.core.Grid$Builder gridBuilder -> a
    us.blanshard.sudoku.core.Marks$Builder marksBuilder -> b
    boolean hasErrors -> c
    us.blanshard.sudoku.insight.GridMarks$Builder assign(us.blanshard.sudoku.core.Assignment) -> a
    us.blanshard.sudoku.insight.GridMarks$Builder assign(us.blanshard.sudoku.core.Location,us.blanshard.sudoku.core.Numeral) -> a
    us.blanshard.sudoku.insight.GridMarks$Builder eliminate(us.blanshard.sudoku.core.Assignment) -> b
    us.blanshard.sudoku.insight.GridMarks$Builder eliminate(us.blanshard.sudoku.core.Location,us.blanshard.sudoku.core.Numeral) -> b
    us.blanshard.sudoku.insight.GridMarks$Builder apply(java.lang.Iterable) -> a
    us.blanshard.sudoku.insight.GridMarks build() -> a
us.blanshard.sudoku.insight.Implication -> us.blanshard.sudoku.c.n:
    com.google.common.collect.ImmutableList antecedents -> b
    us.blanshard.sudoku.insight.Insight consequent -> c
    boolean isError() -> a_
    boolean isAssignment() -> b_
    us.blanshard.sudoku.core.Assignment getImpliedAssignment() -> i
    java.util.Collection getEliminations() -> d
    us.blanshard.sudoku.insight.Insight getNub() -> e
    int getDepth() -> f
    int getCount() -> g
    java.lang.String toShortString() -> h
    com.google.common.collect.ImmutableList getAntecedents() -> c
    us.blanshard.sudoku.insight.Insight getConsequent() -> j
    void apply(us.blanshard.sudoku.insight.GridMarks$Builder) -> a
    boolean isImpliedBy(us.blanshard.sudoku.insight.GridMarks) -> a
    boolean mightBeRevealedByElimination(us.blanshard.sudoku.core.Assignment) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
us.blanshard.sudoku.insight.Insight -> us.blanshard.sudoku.c.o:
    us.blanshard.sudoku.insight.Insight$Type type -> a
    boolean isError() -> a_
    boolean isAssignment() -> b_
    us.blanshard.sudoku.core.Assignment getImpliedAssignment() -> i
    java.util.Collection getEliminations() -> d
    us.blanshard.sudoku.insight.Insight getNub() -> e
    int getDepth() -> f
    int getCount() -> g
    java.lang.String toShortString() -> h
    void apply(us.blanshard.sudoku.insight.GridMarks$Builder) -> a
    boolean isImpliedBy(us.blanshard.sudoku.insight.GridMarks) -> a
    boolean mightBeRevealedByElimination(us.blanshard.sudoku.core.Assignment) -> a
us.blanshard.sudoku.insight.Insight$Type -> us.blanshard.sudoku.c.p:
    us.blanshard.sudoku.insight.Insight$Type CONFLICT -> a
    us.blanshard.sudoku.insight.Insight$Type BARRED_LOCATION -> b
    us.blanshard.sudoku.insight.Insight$Type BARRED_NUMERAL -> c
    us.blanshard.sudoku.insight.Insight$Type FORCED_LOCATION -> d
    us.blanshard.sudoku.insight.Insight$Type FORCED_NUMERAL -> e
    us.blanshard.sudoku.insight.Insight$Type OVERLAP -> f
    us.blanshard.sudoku.insight.Insight$Type LOCKED_SET -> g
    us.blanshard.sudoku.insight.Insight$Type IMPLICATION -> h
    us.blanshard.sudoku.insight.Insight$Type DISPROVED_ASSIGNMENT -> i
    us.blanshard.sudoku.insight.Insight$Type UNFOUNDED_ASSIGNMENT -> j
    java.util.EnumSet ERRORS -> k
    java.util.EnumSet ASSIGNMENTS -> l
    java.util.EnumSet ELIMINATIONS -> m
    us.blanshard.sudoku.insight.Insight$Type[] ENUM$VALUES -> n
    boolean isError() -> a
    boolean isAssignment() -> b
    us.blanshard.sudoku.insight.Insight$Type[] values() -> values
    us.blanshard.sudoku.insight.Insight$Type valueOf(java.lang.String) -> valueOf
us.blanshard.sudoku.insight.LockedSet -> us.blanshard.sudoku.c.q:
    us.blanshard.sudoku.core.NumSet nums -> b
    us.blanshard.sudoku.core.UnitSubset locs -> c
    boolean isNaked -> d
    java.util.Collection eliminations -> e
    java.util.Collection getEliminations() -> d
    us.blanshard.sudoku.core.NumSet getNumerals() -> c
    us.blanshard.sudoku.core.UnitSubset getLocations() -> j
    void apply(us.blanshard.sudoku.insight.GridMarks$Builder) -> a
    boolean isImpliedBy(us.blanshard.sudoku.insight.GridMarks) -> a
    boolean mightBeRevealedByElimination(us.blanshard.sudoku.core.Assignment) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
us.blanshard.sudoku.insight.Overlap -> us.blanshard.sudoku.c.r:
    us.blanshard.sudoku.core.Unit unit -> b
    us.blanshard.sudoku.core.Numeral numeral -> c
    us.blanshard.sudoku.core.UnitSubset extra -> d
    java.util.Collection eliminations -> e
    java.util.Collection getEliminations() -> d
    us.blanshard.sudoku.core.Unit getUnit() -> c
    us.blanshard.sudoku.core.Numeral getNumeral() -> j
    us.blanshard.sudoku.core.Unit getOverlappingUnit() -> k
    void apply(us.blanshard.sudoku.insight.GridMarks$Builder) -> a
    boolean isImpliedBy(us.blanshard.sudoku.insight.GridMarks) -> a
    boolean mightBeRevealedByElimination(us.blanshard.sudoku.core.Assignment) -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
us.blanshard.sudoku.insight.UnfoundedAssignment -> us.blanshard.sudoku.c.s:
    us.blanshard.sudoku.core.Assignment assignment -> b
    us.blanshard.sudoku.core.Assignment getImpliedAssignment() -> i
    void apply(us.blanshard.sudoku.insight.GridMarks$Builder) -> a
    boolean isImpliedBy(us.blanshard.sudoku.insight.GridMarks) -> a
    boolean mightBeRevealedByElimination(us.blanshard.sudoku.core.Assignment) -> a
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
