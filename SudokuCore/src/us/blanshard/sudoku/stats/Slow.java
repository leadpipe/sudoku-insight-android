/*
Copyright 2011 Google Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package us.blanshard.sudoku.stats;

import us.blanshard.sudoku.core.Grid;
import us.blanshard.sudoku.core.Solver;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.math.BigInteger;
import java.util.Random;

/**
 * Reads a TSV file like that generated by {@link GenStats} looking for puzzles
 * that took many steps to solve, and solves them several times with different
 * seeds, recording the numbers of steps required for each attempt by writing to
 * standard output.
 *
 * @author Luke Blanshard
 */
public class Slow {
  private static final int STEPS_CUTOFF = 32;  // Over this we consider slow.
  private static final int NUM_RETRIES = 10;  // How many times to re-solve slow puzzles.

  public static void main(String[] args) throws IOException {
    if (args.length != 1) exitWithUsage();

    BufferedReader r;
    try {
      r = new BufferedReader(new FileReader(args[0]));
    } catch (IOException e) {
      exitWithUsage();
      return;  // Convince the compiler.
    }

    r.mark(10000);
    String line = r.readLine();
    if (line.startsWith("Generating")) {
      r.readLine();  // Skip 2nd line too.
    } else {
      r.reset();  // Start over.
    }

    while ((line = r.readLine()) != null) {
      String[] fields = line.split("\\t");
      int fnum = 5;
      for (Solver.Strategy strategy : Solver.Strategy.values()) {
        rerunIfSlow(fields, fnum, strategy);
        fnum += 6;
      }
    }
  }

  private static void exitWithUsage() {
    System.err.println("Usage: Slow <filename>");
    System.exit(1);
  }

  private static void rerunIfSlow(
      String[] fields, int stepIndex, Solver.Strategy strategy) {
    if (Integer.parseInt(fields[stepIndex]) > STEPS_CUTOFF) {
      Grid start = Grid.fromString(fields[0]);
      Random random = new Random(decode(fields[3]));
      int numSolutions = Integer.parseInt(fields[stepIndex - 1]);

      // First 3 fields: the starting grid, the number of solutions, the strategy.
      System.out.printf("%s\t%d\t%s", fields[0], numSolutions, strategy);

      for (int i = 0; i < NUM_RETRIES; ++i) {
        Solver.Result result = Solver.solve(start, random, strategy);
        System.out.printf("\t%d\t%d", result.numSteps, result.numStepsAfterSolution);
        if (result.numSolutions != numSolutions) {
          System.err.printf("Solver error: %s produced %d solutions instead of %d for %s%n",
                            strategy, result.numSolutions, numSolutions, fields[0]);
        }
      }
      System.out.println();
    }
  }

  private static long decode(String s) {
    if (s.startsWith("0x")) return new BigInteger(s.substring(2), 16).longValue();
    return Long.decode(s);  // Can't use generally because it barfs on too-large numbers.
  }
}
