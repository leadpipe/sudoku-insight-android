* Insights
** TODO Figure out how to turn game histories into pattern times

** Getting games with history from a sqlite db into a tsv file:
sqlite3 phone-2012-07-08.db <<END
.mode tabs
.output games-phone-2012-07-08.tsv
select p.puzzle, g.history from puzzle p, game g where g.puzzleId = p._id and g.gameState >= 3;
END

* Game
** TODO Rename getState to... what?

* App

** App/UI cleanups
*** TODO Improve layout on tablets
    - make play grid larger, replay grid smaller; max ~30% differential
    - ensure capture grid matches play grid
*** TODO Increase escape radius for input
    - really annoyingly small on tablet
*** TODO Show stats on puzzle detail page
    - make new RPC
    - show always?  or only if completed?
*** TODO bug: somehow wound up getting shown completed puzzles
    - each time I started the app it advanced 3-4 in the history
    - find and fix the bug; but also harden the fragment against future similar
      bugs, by _not_ updating the DB when it gets a complete attempt
    - no idea, but did try to make sure the fragment doesn't write these back to the db
*** TODO Change behavior of capture when we already have the puzzle
    - Include a link to the puzzle details
*** TODO Finish help content
*** TODO Show user ID settings page at installation time?
*** TODO Give visual indication when try to set an unsettable location
*** TODO Make translation of symmetry names possible
*** TODO Look into sending crash info to the app engine

** Publishing the app
*** TODO Make other graphics for play store

** Cross-installation work
*** TODO At startup on new installation, show settings page
    - with account selection popup showing?
    - need to trigger login if an account is selected
*** TODO Add pref for whether to sync from other devices
    - dependent on selecting an account
*** TODO Update NetworkService to handle saving of attempts & votes, fetching of stats
    - static collection of operations
      - save installation info
      - save all unsaved attempts & votes
      - save specific attempt or vote
      - fetch all stats last fetched before specific time
      - fetch stats for specific puzzle
    - loop while there are operations in the static set or there are pending RPCs:
      - wait until the network is available
    - translate any operations into pending RPCs
      - installation info, if different from what's already saved
      - save attempt
      - save vote
      - fetch stats
    - Q: try to prioritize these?  or just go in order?
    - send next RPC, handle response
      - future: send them in batches
    - if transient error, put RPC(s) back in pending collection and sleep awhile
    - back to loop

** Replay cleanups
*** TODO Revise calculation and display of disproofs
    - find all disproofs (not just one per open location)
    - don't minimize them right away
    - add a new phase to calculate the efficacy of each disproof: the proportion
      of open locations that get assignments when insights are gathered after
      the disproof is applied
    - show the efficacy as hue between purple (least) and blue (most)
    - for locations with disproofs not yet evaluated for efficacy, use orange
    - for a given location, display the most effective disproof
    - use saturation/value to show length of disproof; so will get brighter
      after minimization
*** TODO Wrong-numeral mistakes show without the error during single-step playback
    - the error appears while running forward
*** TODO Try making selection color darker
*** TODO Try not minimizing disproofs until they're selected
*** TODO Why does the first trail in puzzle 14 switch errors?
*** TODO Automatically pause the replay on switch of trail, just after the move
    - Or, rethink this.  Not clear it would be helpful.
    - It would be nice to be able to jump past trail switches
*** TODO Bug: analysis not being interrupted
    - No longer seeing this?
*** TODO Clearing the present insight should clear the selected location too
    - should it also clear the error displayed?
    - or possibly everything but the nub of the error?
*** TODO Think about animation of insight display
    - for complex implications, this could help the visualization

** List view ideas
*** TODO Add a count to the list spinner: #puzzles in collection
*** TODO Handle the importing of collections of puzzles
    - Add an activity that's triggered by .sdm files
    - Change the way we set up new attempts: look for attempt-less puzzles and queue one
    - Still want to generate new puzzles: add a pref for how often to do this, as
      a number between 0 and 1 (probably with 4-5 discrete choices: never,
      occasionally, etc)
*** TODO Consider supporting other selection-based operations on the list: deletion, exporting


* App engine app

** Missing pieces
*** TODO Implement batch RPC
*** TODO Have a config object containing, eg, num streams?

** Protocols

** API from phone
   - Send installation info:
     - installation ID
     - phone model info
     - email address (opt)
     - generation stream number
   - > return generation stream number (opt)
     - and puzzles & attempts from other installations
     - and other installations info
     - and recommended puzzles?
   - Send attempt:
     - installation ID
     - attempt ID -- why not?
     - puzzle
     - puzzle params
     - history -- log and drop if history's > say 50k
     - startTime, stopTime
   - Send vote:
     - installation ID
     - puzzle
     - vote
   - Get puzzle stats

** Push notifications to phone
   - Recommended puzzle
   - Other installation info updated

** Schema
   - Installation: root, key = installation ID
     - optional email address (with index)
     - opaque ID with index (generated)
     - phone model, generation stream number
     - PuzzleHistory: child, key = puzzle string
       - index on puzzle string
       - source, generation params
       - contains all attempt histories (up to 20 or something)
         - each with history string, elapsed time, #moves, #trails,
           solved/gave up flag, attempt ID from phone, startTime, stopTime
       - if not first installation for this user that tackled this puzzle,
         pointer to the one that was first
   - Puzzle: root, key = puzzle string
     - contains generation params if applicable
     - contains puzzle sources and installation IDs they came from
     - contains summary of stats on this puzzle:
       - how many played
       - how many won on first attempt
       - avg elapsed time
       - avg #moves
       - avg #trails
       - perhaps distributions of above
   - User: root, key = email address
     - opaque ID with index (generated)
     - contains list of installation IDs

** The web app
   - sample puzzles?
   - stats? num puzzles? num installations? num users? rates of change?
   - for logged-in users, info about their stuff

** Constraints
   - The installation ID and email address are secret--can't let them leak out of the app engine app
   - So we need alternative IDs that we expose and index on
   - Is there an encryption service?  Is it possible to have params not visible via source?

* Math
** Pathological grids
   - How bad can they get?
*** TODO Solve one in the debugger, see what's going on

** Canonical grids
   - How to compare two grids for equivalence?
   - Possible permutations that preserve constraints:
     - transposition
     - permutation of numerals
     - permutation of block-rows or block-columns
     - permutation of rows within a block-row or columns within a block-column
     - rotation (can it be expressed by the others? -- yes)
*** TODO Re-read the "how many sudokus" paper
    - Canonical grid?

* References
** J. F. Crook: A Pencil-and-Paper Algorithm for Solving Sudoku Puzzles
   - http://www.ams.org/notices/200904/tx090400460p.pdf
   - The trails approach, essentially, including different colors
** George A. Miller:
   - http://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two
   - ~7 chunks of information in working memory
   - The other dimension where 7 appears is ~7 levels of absolute judgement, eg
     loudness of a sound, or pitch, or location along a line.  This really
     _doesn't_ apply to Sudoku.  It's all working memory.

* Talk
** What is Sudoku?
   - a logic puzzle; more precisely, a (large) family of logic puzzles
   - 9x9 grid; each empty square must be filled with a numeral between 1 and 9
   - the finished puzzle has all 9 numerals in every row, column, and 3x3 block
   - a given puzzle usually has a single solution
** How Large a Family of Logic Puzzles?
   - 5e9 distinct canonical solution grids
   - for each one, 9! x 6^8 x 2 = 1.2e12 permutations
   - total: 6e21
   - each solution grid represents lots of different puzzles -- on the order of 81! = 5.8e120
   - in human terms: an infinite supply of sudoku
   - astonishingly: a huge variety of puzzles
   - (best canonicalization scheme: first in lexicographical order)
** Why is Sudoku Fun?
   - My theory: 7 +/- 2
** The Pessimistic View
   - Sudoku is "a denial of service attack on human intellect" -- Ben Laurie,
     quoted by Peter Norvig
** Solving via Computer
   - Constraint propagation & search
   - Norvig has a one-page Python program, done supposedly to free mankind of
     the scourge of Sudoku addiction
   - (turns out it can be used to spread the addiction as well)
   - It's super fast for a computer to solve a Sudoku
   - Measured in microseconds on my old MBP (~300us avg)
*** Constraint propagation
    - assign(loc, num):
      for each other numeral that could be in loc:
        eliminate(loc, other)
    - eliminate(loc, num):
      remove num as a possibility in loc
      if loc ends up with just 1 possibility:
        for each peer location of loc:
          eliminate(peer, poss)
      for each unit loc is in:
        if num is now in just 1 of that unit's locations:
          assign(there, num)
*** Search
    - search(possibilities):
      - if all locations have 1 possibility: success
      - if any location has 0 possibilities: failure
      - choose a location from among those with the fewest number of possibilities
      - for each possible numeral:
          try assign(loc, num); if search with those possibilities succeeds, success
      - failure
** Solving via Intellect

